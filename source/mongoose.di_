import core.stdc.config;
import core.stdc.inttypes;
import core.stdc.limits;
import core.stdc.time;
import core.stdc.stdio;
import core.sys.posix.arpa.inet;
import core.sys.posix.sys.stat;
import core.sys.posix.sys.types;
public import core.sys.posix.netinet.in_;

extern (C):

/*
 * Copyright (c) 2004-2013 Sergey Lyubka
 * Copyright (c) 2013-2015 Cesanta Software Limited
 * All rights reserved
 *
 * This software is dual-licensed: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation. For the terms of this
 * license, see <http://www.gnu.org/licenses/>.
 *
 * You are free to use this software under the terms of the GNU General
 * Public License, but WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * Alternatively, you can license this software under a commercial
 * license, as set out in <https://www.cesanta.com/license>.
 */

enum MG_VERSION = "6.16";

/* Local tweaks, applied before any of Mongoose's own headers. */

/* CS_MONGOOSE_SRC_COMMON_H_ */

/*
 * For the "custom" platform, includes and dependencies can be
 * provided through mg_locals.h.
 */
enum CS_P_CUSTOM = 0;
enum CS_P_UNIX = 1;
enum CS_P_WINDOWS = 2;
enum CS_P_ESP32 = 15;
enum CS_P_ESP8266 = 3;
enum CS_P_CC3100 = 6;
enum CS_P_CC3200 = 4;
enum CS_P_CC3220 = 17;
enum CS_P_MSP432 = 5;
enum CS_P_TM4C129 = 14;
enum CS_P_MBED = 7;
enum CS_P_WINCE = 8;
enum CS_P_NXP_LPC = 13;
enum CS_P_NXP_KINETIS = 9;
enum CS_P_NRF51 = 12;
enum CS_P_NRF52 = 10;
enum CS_P_PIC32 = 11;
enum CS_P_RS14100 = 18;
enum CS_P_STM32 = 16;
/* Next id: 19 */

/* If not specified explicitly, we guess platform by defines. */

enum CS_PLATFORM = CS_P_UNIX;

/* !defined(CS_PLATFORM) */

enum MG_NET_IF_SOCKET = 1;
enum MG_NET_IF_SIMPLELINK = 2;
enum MG_NET_IF_LWIP_LOW_LEVEL = 3;
enum MG_NET_IF_PIC32 = 4;
enum MG_NET_IF_NULL = 5;

enum MG_SSL_IF_OPENSSL = 1;
enum MG_SSL_IF_MBEDTLS = 2;
enum MG_SSL_IF_SIMPLELINK = 3;

/* Amalgamated: #include "common/platforms/platform_unix.h" */
/* Amalgamated: #include "common/platforms/platform_windows.h" */
/* Amalgamated: #include "common/platforms/platform_esp32.h" */
/* Amalgamated: #include "common/platforms/platform_esp8266.h" */
/* Amalgamated: #include "common/platforms/platform_cc3100.h" */
/* Amalgamated: #include "common/platforms/platform_cc3200.h" */
/* Amalgamated: #include "common/platforms/platform_cc3220.h" */
/* Amalgamated: #include "common/platforms/platform_mbed.h" */
/* Amalgamated: #include "common/platforms/platform_nrf51.h" */
/* Amalgamated: #include "common/platforms/platform_nrf52.h" */
/* Amalgamated: #include "common/platforms/platform_wince.h" */
/* Amalgamated: #include "common/platforms/platform_nxp_lpc.h" */
/* Amalgamated: #include "common/platforms/platform_nxp_kinetis.h" */
/* Amalgamated: #include "common/platforms/platform_pic32.h" */
/* Amalgamated: #include "common/platforms/platform_rs14100.h" */
/* Amalgamated: #include "common/platforms/platform_stm32.h" */

/* Common stuff */

/* __GNUC__ */

extern (D) size_t ARRAY_SIZE(T)(auto ref T array)
{
    return array.sizeof / (array[0]).sizeof;
}

/* CS_COMMON_PLATFORM_H_ */

/*
 * MSVC++ 14.0 _MSC_VER == 1900 (Visual Studio 2015)
 * MSVC++ 12.0 _MSC_VER == 1800 (Visual Studio 2013)
 * MSVC++ 11.0 _MSC_VER == 1700 (Visual Studio 2012)
 * MSVC++ 10.0 _MSC_VER == 1600 (Visual Studio 2010)
 * MSVC++ 9.0  _MSC_VER == 1500 (Visual Studio 2008)
 * MSVC++ 8.0  _MSC_VER == 1400 (Visual Studio 2005)
 * MSVC++ 7.1  _MSC_VER == 1310 (Visual Studio 2003)
 * MSVC++ 7.0  _MSC_VER == 1300
 * MSVC++ 6.0  _MSC_VER == 1200
 * MSVC++ 5.0  _MSC_VER == 1100
 */

/* FD_SET() emits warning, disable it */
/* missing c99 support */

/* Linking with winsock library */

/* https://stackoverflow.com/questions/16647819/timegm-cross-platform */

/* CS_PLATFORM == CS_P_WINDOWS */
/* CS_COMMON_PLATFORMS_PLATFORM_WINDOWS_H_ */

enum _XOPEN_SOURCE = 600;

/* <inttypes.h> wants this for C++ */

/* C++ wants that for INT64_MAX */

/* Enable fseeko() and ftello() functions */

enum _LARGEFILE_SOURCE = 1;

/* Enable 64-bit file offsets */

enum _FILE_OFFSET_BITS = 64;

/*
 * osx correctly avoids defining strtoll when compiling in strict ansi mode.
 * c++ 11 standard defines strtoll as well.
 * We require strtoll, and if your embedded pre-c99 compiler lacks one, please
 * implement a shim.
 */

long strtoll (const(char)*, char**, int);

alias sock_t = int;
enum INVALID_SOCKET = -1;
enum SIZE_T_FMT = "zu";
alias cs_stat_t = stat_t;
enum DIRSEP = '/';

extern (D) auto to64(T)(auto ref T x)
{
    return strtoll(x, NULL, 10);
}

enum INT64_FMT = PRId64;
enum INT64_X_FMT = PRIx64;

enum MG_MAX_HTTP_REQUEST_SIZE = 8192;

enum MG_MAX_HTTP_SEND_MBUF = 4096;

enum MG_MAX_HTTP_HEADERS = 40;

enum CS_ENABLE_STDIO = 1;

enum MG_ENABLE_BROADCAST = 1;

enum MG_ENABLE_DIRECTORY_LISTING = 1;

enum MG_ENABLE_FILESYSTEM = 1;

enum MG_ENABLE_HTTP_CGI = MG_ENABLE_FILESYSTEM;

enum MG_NET_IF = MG_NET_IF_SOCKET;

enum MG_HOSTS_FILE_NAME = "/etc/hosts";

enum MG_RESOLV_CONF_FILE_NAME = "/etc/resolv.conf";

/* CS_PLATFORM == CS_P_UNIX */
/* CS_COMMON_PLATFORMS_PLATFORM_UNIX_H_ */

/*
 * Copyright (c) 2014-2018 Cesanta Software Limited
 * All rights reserved
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* CS_PLATFORM == CS_P_ESP32 */
/* CS_COMMON_PLATFORMS_PLATFORM_ESP32_H_ */

/*
 * Copyright (c) 2014-2018 Cesanta Software Limited
 * All rights reserved
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* struct timeval is defined in sys/time.h. */

/* RTOS SDK has LWIP sockets */

/* CS_PLATFORM == CS_P_ESP8266 */
/* CS_COMMON_PLATFORMS_PLATFORM_ESP8266_H_ */

/*
 * Copyright (c) 2014-2018 Cesanta Software Limited
 * All rights reserved
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * CC3100 SDK and STM32 SDK include headers w/out path, just like
 * #include "simplelink.h". As result, we have to add all required directories
 * into Makefile IPATH and do the same thing (include w/out path)
 */

/* CS_PLATFORM == CS_P_CC3100 */
/* CS_COMMON_PLATFORMS_PLATFORM_CC3100_H_ */

/*
 * Copyright (c) 2014-2018 Cesanta Software Limited
 * All rights reserved
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Only SPIFFS supports directories, SLFS does not. */

/* Amalgamated: #include "common/platforms/simplelink/cs_simplelink.h" */

/* Some functions we implement for Mongoose. */

/* TI's libc does not have stat & friends, add them. */

/* 5.x series compilers don't have va_copy, 16.x do. */

/* __TI_COMPILER_VERSION__ */

/* CS_PLATFORM == CS_P_CC3200 */
/* CS_COMMON_PLATFORMS_PLATFORM_CC3200_H_ */

/*
 * Copyright (c) 2014-2018 Cesanta Software Limited
 * All rights reserved
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Only SPIFFS supports directories, SLFS does not. */

/* Amalgamated: #include "common/platforms/simplelink/cs_simplelink.h" */

/* Some functions we implement for Mongoose. */

/* TI's libc does not have stat & friends, add them. */

/* __TI_COMPILER_VERSION__ */

/* CS_PLATFORM == CS_P_CC3220 */
/* CS_COMMON_PLATFORMS_PLATFORM_CC3200_H_ */

/*
 * Copyright (c) 2014-2018 Cesanta Software Limited
 * All rights reserved
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Amalgamated: #include "common/platforms/simplelink/cs_simplelink.h" */

/* Some functions we implement for Mongoose. */

/* TI's libc does not have stat & friends, add them. */

/* As of 5.2.7, TI compiler does not support va_copy() yet. */

/* __TI_COMPILER_VERSION__ */

/* CS_PLATFORM == CS_P_MSP432 */
/* CS_COMMON_PLATFORMS_PLATFORM_MSP432_H_ */

/*
 * Copyright (c) 2014-2018 Cesanta Software Limited
 * All rights reserved
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Amalgamated: #include "common/platforms/simplelink/cs_simplelink.h" */

/* As of 5.2.8, TI compiler does not support va_copy() yet. */

/* __TI_COMPILER_VERSION__ */

/* CS_PLATFORM == CS_P_TM4C129 */
/* CS_COMMON_PLATFORMS_PLATFORM_TM4C129_H_ */

/*
 * Copyright (c) 2014-2018 Cesanta Software Limited
 * All rights reserved
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * mbed.h contains C++ code (e.g. templates), thus, it should be processed
 * only if included directly to startup file (ex: main.cpp)
 */

/* Amalgamated: #include "mbed.h" */
/* __cplusplus */

/*
 * mbed can be compiled with the ARM compiler which
 * just doesn't come with a gettimeofday shim
 * because it's a BSD API and ARM targets embedded
 * non-unix platforms.
 */

/* copied from GCC on ARM; for some reason useconds are signed */
/* microseconds (signed) */

/* seconds */
/* and microseconds */

/* MG_NET_IF == MG_NET_IF_SIMPLELINK */

/* CS_PLATFORM == CS_P_MBED */
/* CS_COMMON_PLATFORMS_PLATFORM_MBED_H_ */

/*
 * Copyright (c) 2014-2018 Cesanta Software Limited
 * All rights reserved
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * For ARM C Compiler, make lwip to export `struct timeval`; for other
 * compilers, suppress it.
 */

/*
 * ARM C Compiler doesn't have strdup, so we provide it
 */

/* CS_PLATFORM == CS_P_NRF51 */
/* CS_COMMON_PLATFORMS_PLATFORM_NRF51_H_ */

/*
 * Copyright (c) 2014-2018 Cesanta Software Limited
 * All rights reserved
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* No space left on device */

/*
 * For ARM C Compiler, make lwip to export `struct timeval`; for other
 * compilers, suppress it.
 */

/*
 * ARM C Compiler doesn't have strdup, so we provide it
 */

/* CS_PLATFORM == CS_P_NRF52 */
/* CS_COMMON_PLATFORMS_PLATFORM_NRF52_H_ */

/*
 * Copyright (c) 2014-2018 Cesanta Software Limited
 * All rights reserved
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* If simplelink.h is already included, all bets are off. */

/* We want to disable SL_INC_STD_BSD_API_NAMING, so we include user.h ourselves
 * and undef it. */

/* CS_PLATFORM == CS_P_CC3220 */

/* Now define only the subset of the BSD API that we use.
 * Notably, close(), read() and write() are not defined. */

/* !defined(__SIMPLELINK_H__) */

/* Compatibility with older versions of SimpleLink */

/* SL_MAJOR_VERSION_NUM >= 2 */

/* SL_MAJOR_VERSION_NUM < 2 */

/* MG_NET_IF == MG_NET_IF_SIMPLELINK */

/* CS_COMMON_PLATFORMS_SIMPLELINK_CS_SIMPLELINK_H_ */

/*
 * MSVC++ 14.0 _MSC_VER == 1900 (Visual Studio 2015)
 * MSVC++ 12.0 _MSC_VER == 1800 (Visual Studio 2013)
 * MSVC++ 11.0 _MSC_VER == 1700 (Visual Studio 2012)
 * MSVC++ 10.0 _MSC_VER == 1600 (Visual Studio 2010)
 * MSVC++ 9.0  _MSC_VER == 1500 (Visual Studio 2008)
 * MSVC++ 8.0  _MSC_VER == 1400 (Visual Studio 2005)
 * MSVC++ 7.1  _MSC_VER == 1310 (Visual Studio 2003)
 * MSVC++ 7.0  _MSC_VER == 1300
 * MSVC++ 6.0  _MSC_VER == 1200
 * MSVC++ 5.0  _MSC_VER == 1100
 */
/* FD_SET() emits warning, disable it */
/* missing c99 support */

/* Linking with WinCE winsock library */

/* TODO(alashkin): check if this is correct */

/*
 * Explicitly disabling MG_ENABLE_THREADS for WinCE
 * because they are enabled for _WIN32 by default
 */

/*
 * WinCE 6.0 has a lot of useful definitions in ATL (not windows.h) headers
 * use #ifdefs to avoid conflicts
 */

/* CS_PLATFORM == CS_P_WINCE */
/* CS_COMMON_PLATFORMS_PLATFORM_WINCE_H_ */

/*
 * Copyright (c) 2014-2018 Cesanta Software Limited
 * All rights reserved
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * LPCXpress comes with 3 C library implementations: Newlib, NewlibNano and
 *Redlib.
 * See https://community.nxp.com/message/630860 for more details.
 *
 * Redlib is the default and lacks certain things, so we provide them.
 */

/* Let LWIP define timeval for us. */

/* CS_PLATFORM == CS_P_NXP_LPC */
/* CS_COMMON_PLATFORMS_PLATFORM_NXP_LPC_H_ */

/*
 * Copyright (c) 2014-2018 Cesanta Software Limited
 * All rights reserved
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* struct timeval is defined in sys/time.h. */

/* CS_PLATFORM == CS_P_NXP_KINETIS */
/* CS_COMMON_PLATFORMS_PLATFORM_NXP_KINETIS_H_ */

/*
 * Copyright (c) 2014-2018 Cesanta Software Limited
 * All rights reserved
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* CS_PLATFORM == CS_P_PIC32 */

/* CS_COMMON_PLATFORMS_PLATFORM_PIC32_H_ */

/*
 * Copyright (c) 2014-2019 Cesanta Software Limited
 * All rights reserved
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* CS_PLATFORM == CS_P_RS14100 */
/* CS_COMMON_PLATFORMS_PLATFORM_RS14100_H_ */

/*
 * Copyright (c) 2014-2018 Cesanta Software Limited
 * All rights reserved
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* CS_PLATFORM == CS_P_STM32 */
/* CS_COMMON_PLATFORMS_PLATFORM_STM32_H_ */

/*
 * Copyright (c) 2014-2018 Cesanta Software Limited
 * All rights reserved
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

enum MG_LWIP = 0;

/*
 * When compiling for nRF5x chips with arm-none-eabi-gcc, it has BYTE_ORDER
 * already defined, so in order to avoid warnings in lwip, we have to undefine
 * it.
 *
 * TODO: Check if in the future versions of nRF5 SDK that changes.
 *       Current version of nRF51 SDK: 0.8.0
 *                          nRF5 SDK:  0.9.0
 */

/* We really need the definitions from sockets.h. */

/* For older version of LWIP */

/* MG_LWIP */

/* CS_COMMON_PLATFORMS_LWIP_MG_LWIP_H_ */

/*
 * Copyright (c) 2014-2018 Cesanta Software Limited
 * All rights reserved
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Amalgamated: #include "common/platform.h" */

enum CS_DISABLE_MD5 = 0;

/* __cplusplus */

struct cs_md5_ctx
{
    uint[4] buf;
    uint[2] bits;
    ubyte[64] in_;
}

void cs_md5_init (cs_md5_ctx* c);
void cs_md5_update (cs_md5_ctx* c, const(ubyte)* data, size_t len);
void cs_md5_final (ubyte* md, cs_md5_ctx* c);

/* __cplusplus */

/* CS_COMMON_MD5_H_ */

/*
 * Copyright (c) 2014-2018 Cesanta Software Limited
 * All rights reserved
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

enum CS_DISABLE_SHA1 = 0;

/* Amalgamated: #include "common/platform.h" */

/* __cplusplus */

struct cs_sha1_ctx
{
    uint[5] state;
    uint[2] count;
    ubyte[64] buffer;
}

void cs_sha1_init (cs_sha1_ctx*);
void cs_sha1_update (cs_sha1_ctx*, const(ubyte)* data, uint len);
void cs_sha1_final (ref ubyte[20] digest, cs_sha1_ctx*);
void cs_hmac_sha1 (
    const(ubyte)* key,
    size_t key_len,
    const(ubyte)* text,
    size_t text_len,
    ref ubyte[20] out_);

/* __cplusplus */

/* CS_DISABLE_SHA1 */

/* CS_COMMON_SHA1_H_ */

/*
 * Copyright (c) 2014-2018 Cesanta Software Limited
 * All rights reserved
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Amalgamated: #include "common/platform.h" */

/* __cplusplus */

/* Sub-second granularity time(). */
double cs_time ();

/*
 * Similar to (non-standard) timegm, converts broken-down time into the number
 * of seconds since Unix Epoch.
 */
double cs_timegm (const(tm)* tm);

/* __cplusplus */

/* CS_COMMON_CS_TIME_H_ */

/*
 * Copyright (c) 2014-2018 Cesanta Software Limited
 * All rights reserved
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Describes chunk of memory */
struct mg_str
{
    const(char)* p; /* Memory chunk pointer */
    size_t len; /* Memory chunk length */
}

/*
 * Helper function for creating mg_str struct from plain C string.
 * `NULL` is allowed and becomes `{NULL, 0}`.
 */
mg_str mg_mk_str (const(char)* s);

/*
 * Like `mg_mk_str`, but takes string length explicitly.
 */
mg_str mg_mk_str_n (const(char)* s, size_t len);

/* Macro for initializing mg_str. */

/*
 * Cross-platform version of `strcmp()` where where first string is
 * specified by `struct mg_str`.
 */
int mg_vcmp (const(mg_str)* str2, const(char)* str1);

/*
 * Cross-platform version of `strncasecmp()` where first string is
 * specified by `struct mg_str`.
 */
int mg_vcasecmp (const(mg_str)* str2, const(char)* str1);

/* Creates a copy of s (heap-allocated). */
mg_str mg_strdup (const mg_str s);

/*
 * Creates a copy of s (heap-allocated).
 * Resulting string is NUL-terminated (but NUL is not included in len).
 */
mg_str mg_strdup_nul (const mg_str s);

/*
 * Locates character in a string.
 */
const(char)* mg_strchr (const mg_str s, int c);

/*
 * Compare two `mg_str`s; return value is the same as `strcmp`.
 */
int mg_strcmp (const mg_str str1, const mg_str str2);

/*
 * Like `mg_strcmp`, but compares at most `n` characters.
 */
int mg_strncmp (const mg_str str1, const mg_str str2, size_t n);

/*
 * Free the string (assuming it was heap allocated).
 */
void mg_strfree (mg_str* s);

/*
 * Finds the first occurrence of a substring `needle` in the `haystack`.
 */
const(char)* mg_strstr (const mg_str haystack, const mg_str needle);

/* Strip whitespace at the start and the end of s */
mg_str mg_strstrip (mg_str s);

/* Returns 1 if s starts with the given prefix. */
int mg_str_starts_with (mg_str s, mg_str prefix);

/* CS_COMMON_MG_STR_H_ */

/*
 * Copyright (c) 2014-2018 Cesanta Software Limited
 * All rights reserved
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Mbufs are mutable/growing memory buffers, like C++ strings.
 * Mbuf can append data to the end of a buffer or insert data into arbitrary
 * position in the middle of a buffer. The buffer grows automatically when
 * needed.
 */

/* Amalgamated: #include "common/platform.h" */

/* Memory buffer descriptor */
struct mbuf
{
    char* buf; /* Buffer pointer */
    size_t len; /* Data length. Data is located between offset 0 and len. */
    size_t size; /* Buffer size allocated by realloc(1). Must be >= len */
}

/*
 * Initialises an Mbuf.
 * `initial_capacity` specifies the initial capacity of the mbuf.
 */
void mbuf_init (mbuf*, size_t initial_capacity);

/* Frees the space allocated for the mbuffer and resets the mbuf structure. */
void mbuf_free (mbuf*);

/*
 * Appends data to the Mbuf.
 *
 * Returns the number of bytes appended or 0 if out of memory.
 */
size_t mbuf_append (mbuf*, const(void)* data, size_t data_size);

/*
 * Appends data to the Mbuf and frees it (data must be heap-allocated).
 *
 * Returns the number of bytes appended or 0 if out of memory.
 * data is freed irrespective of return value.
 */
size_t mbuf_append_and_free (mbuf*, void* data, size_t data_size);

/*
 * Inserts data at a specified offset in the Mbuf.
 *
 * Existing data will be shifted forwards and the buffer will
 * be grown if necessary.
 * Returns the number of bytes inserted.
 */
size_t mbuf_insert (mbuf*, size_t, const(void)*, size_t);

/* Removes `data_size` bytes from the beginning of the buffer. */
void mbuf_remove (mbuf*, size_t data_size);

/*
 * Resizes an Mbuf.
 *
 * If `new_size` is smaller than buffer's `len`, the
 * resize is not performed.
 */
void mbuf_resize (mbuf*, size_t new_size);

/* Moves the state from one mbuf to the other. */
void mbuf_move (mbuf* from, mbuf* to);

/* Removes all the data from mbuf (if any). */
void mbuf_clear (mbuf*);

/* Shrinks an Mbuf by resizing its `size` to `len`. */
void mbuf_trim (mbuf*);

/* __cplusplus */

/* CS_COMMON_MBUF_H_ */

/*
 * Copyright (c) 2014-2018 Cesanta Software Limited
 * All rights reserved
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

alias cs_base64_putc_t = void function (char, void*);

struct cs_base64_ctx
{
    /* cannot call it putc because it's a macro on some environments */
    cs_base64_putc_t b64_putc;
    ubyte[3] chunk;
    int chunk_size;
    void* user_data;
}

void cs_base64_init (
    cs_base64_ctx* ctx,
    cs_base64_putc_t putc,
    void* user_data);
void cs_base64_update (cs_base64_ctx* ctx, const(char)* str, size_t len);
void cs_base64_finish (cs_base64_ctx* ctx);

void cs_base64_encode (const(ubyte)* src, int src_len, char* dst);
void cs_fprint_base64 (FILE* f, const(ubyte)* src, int src_len);

/*
 * Decodes a base64 string `s` length `len` into `dst`.
 * `dst` must have enough space to hold the result.
 * `*dec_len` will contain the resulting length of the string in `dst`
 * while return value will return number of processed bytes in `src`.
 * Return value == len indicates successful processing of all the data.
 */
int cs_base64_decode (const(ubyte)* s, int len, char* dst, int* dec_len);

/* DISABLE_BASE64 */

/* CS_COMMON_CS_BASE64_H_ */

/*
 * Copyright (c) 2014-2018 Cesanta Software Limited
 * All rights reserved
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Amalgamated: #include "common/mg_str.h" */
/* Amalgamated: #include "common/platform.h" */

/*
 * Expands to a string representation of its argument, which is allowed
 * to be a macro: e.g.
 *
 * #define FOO 123
 * CS_STRINGIFY_MACRO(FOO)
 *
 * expands to 123.
 */

/*
 * Equivalent of standard `strnlen()`.
 */
size_t c_strnlen (const(char)* s, size_t maxlen);

/*
 * Equivalent of standard `snprintf()`.
 */
int c_snprintf (char* buf, size_t buf_size, const(char)* format, ...);

/*
 * Equivalent of standard `vsnprintf()`.
 */
int c_vsnprintf (char* buf, size_t buf_size, const(char)* format, ...);

/*
 * Find the first occurrence of find in s, where the search is limited to the
 * first slen characters of s.
 */
const(char)* c_strnstr (const(char)* s, const(char)* find, size_t slen);

/*
 * Stringify binary data. Output buffer size must be 2 * size_of_input + 1
 * because each byte of input takes 2 bytes in string representation
 * plus 1 byte for the terminating \0 character.
 */
void cs_to_hex (char* to, const(ubyte)* p, size_t len);

/*
 * Convert stringified binary data back to binary.
 * Does the reverse of `cs_to_hex()`.
 */
void cs_from_hex (char* to, const(char)* p, size_t len);

/*
 * Equivalent of standard `strdup()`, defined if only `CS_ENABLE_STRDUP` is 1.
 */

/*
 * Simple string -> int64 conversion routine.
 */

/*
 * Cross-platform version of `strncasecmp()`.
 */
int mg_ncasecmp (const(char)* s1, const(char)* s2, size_t len);

/*
 * Cross-platform version of `strcasecmp()`.
 */
int mg_casecmp (const(char)* s1, const(char)* s2);

/*
 * Prints message to the buffer. If the buffer is large enough to hold the
 * message, it returns buffer. If buffer is to small, it allocates a large
 * enough buffer on heap and returns allocated buffer.
 * This is a supposed use case:
 *
 * ```c
 *    char buf[5], *p = buf;
 *    mg_avprintf(&p, sizeof(buf), "%s", "hi there");
 *    use_p_somehow(p);
 *    if (p != buf) {
 *      free(p);
 *    }
 * ```
 *
 * The purpose of this is to avoid malloc-ing if generated strings are small.
 */
int mg_asprintf (char** buf, size_t size, const(char)* fmt, ...);

/* Same as mg_asprintf, but takes varargs list. */
int mg_avprintf (char** buf, size_t size, const(char)* fmt, ...);

/*
 * A helper function for traversing a comma separated list of values.
 * It returns a list pointer shifted to the next value or NULL if the end
 * of the list found.
 * The value is stored in a val vector. If the value has a form "x=y", then
 * eq_val vector is initialised to point to the "y" part, and val vector length
 * is adjusted to point only to "x".
 * If the list is just a comma separated list of entries, like "aa,bb,cc" then
 * `eq_val` will contain zero-length string.
 *
 * The purpose of this function is to parse comma separated string without
 * any copying/memory allocation.
 */
const(char)* mg_next_comma_list_entry (
    const(char)* list,
    mg_str* val,
    mg_str* eq_val);

/*
 * Like `mg_next_comma_list_entry()`, but takes `list` as `struct mg_str`.
 * NB: Test return value's .p, not .len. On last itreation that yields result
 * .len will be 0 but .p will not. When finished, .p will be NULL.
 */
mg_str mg_next_comma_list_entry_n (mg_str list, mg_str* val, mg_str* eq_val);

/*
 * Matches 0-terminated string (mg_match_prefix) or string with given length
 * mg_match_prefix_n against a glob pattern. Glob syntax:
 * ```
 * - * matches zero or more characters until a slash character /
 * - ** matches zero or more characters
 * - ? Matches exactly one character which is not a slash /
 * - | or ,  divides alternative patterns
 * - any other character matches itself
 * ```
 * Match is case-insensitive. Return number of bytes matched.
 * Examples:
 * ```
 * mg_match_prefix("a*f", len, "abcdefgh") == 6
 * mg_match_prefix("a*f", len, "abcdexgh") == 0
 * mg_match_prefix("a*f|de*,xy", len, "defgh") == 5
 * mg_match_prefix("?*", len, "abc") == 3
 * mg_match_prefix("?*", len, "") == 0
 * ```
 */
size_t mg_match_prefix (const(char)* pattern, int pattern_len, const(char)* str);

/*
 * Like `mg_match_prefix()`, but takes `pattern` and `str` as `struct mg_str`.
 */
size_t mg_match_prefix_n (const mg_str pattern, const mg_str str);

/* CS_COMMON_STR_UTIL_H_ */

/* clang-format off */
/*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)queue.h	8.5 (Berkeley) 8/20/94
 * $FreeBSD$
 */

/*
 * This file defines four types of data structures: singly-linked lists,
 * singly-linked tail queues, lists and tail queues.
 *
 * A singly-linked list is headed by a single forward pointer. The elements
 * are singly linked for minimum space and pointer manipulation overhead at
 * the expense of O(n) removal for arbitrary elements. New elements can be
 * added to the list after an existing element or at the head of the list.
 * Elements being removed from the head of the list should use the explicit
 * macro for this purpose for optimum efficiency. A singly-linked list may
 * only be traversed in the forward direction.  Singly-linked lists are ideal
 * for applications with large datasets and few or no removals or for
 * implementing a LIFO queue.
 *
 * A singly-linked tail queue is headed by a pair of pointers, one to the
 * head of the list and the other to the tail of the list. The elements are
 * singly linked for minimum space and pointer manipulation overhead at the
 * expense of O(n) removal for arbitrary elements. New elements can be added
 * to the list after an existing element, at the head of the list, or at the
 * end of the list. Elements being removed from the head of the tail queue
 * should use the explicit macro for this purpose for optimum efficiency.
 * A singly-linked tail queue may only be traversed in the forward direction.
 * Singly-linked tail queues are ideal for applications with large datasets
 * and few or no removals or for implementing a FIFO queue.
 *
 * A list is headed by a single forward pointer (or an array of forward
 * pointers for a hash table header). The elements are doubly linked
 * so that an arbitrary element can be removed without a need to
 * traverse the list. New elements can be added to the list before
 * or after an existing element or at the head of the list. A list
 * may be traversed in either direction.
 *
 * A tail queue is headed by a pair of pointers, one to the head of the
 * list and the other to the tail of the list. The elements are doubly
 * linked so that an arbitrary element can be removed without a need to
 * traverse the list. New elements can be added to the list before or
 * after an existing element, at the head of the list, or at the end of
 * the list. A tail queue may be traversed in either direction.
 *
 * For details on the use of these macros, see the queue(3) manual page.
 *
 *
 *				SLIST	LIST	STAILQ	TAILQ
 * _HEAD			+	+	+	+
 * _CLASS_HEAD			+	+	+	+
 * _HEAD_INITIALIZER		+	+	+	+
 * _ENTRY			+	+	+	+
 * _CLASS_ENTRY			+	+	+	+
 * _INIT			+	+	+	+
 * _EMPTY			+	+	+	+
 * _FIRST			+	+	+	+
 * _NEXT			+	+	+	+
 * _PREV			-	+	-	+
 * _LAST			-	-	+	+
 * _FOREACH			+	+	+	+
 * _FOREACH_FROM		+	+	+	+
 * _FOREACH_SAFE		+	+	+	+
 * _FOREACH_FROM_SAFE		+	+	+	+
 * _FOREACH_REVERSE		-	-	-	+
 * _FOREACH_REVERSE_FROM	-	-	-	+
 * _FOREACH_REVERSE_SAFE	-	-	-	+
 * _FOREACH_REVERSE_FROM_SAFE	-	-	-	+
 * _INSERT_HEAD			+	+	+	+
 * _INSERT_BEFORE		-	+	-	+
 * _INSERT_AFTER		+	+	+	+
 * _INSERT_TAIL			-	-	+	+
 * _CONCAT			-	-	+	+
 * _REMOVE_AFTER		+	-	+	-
 * _REMOVE_HEAD			+	-	+	-
 * _REMOVE			+	+	+	+
 * _SWAP			+	+	+	+
 *
 */

/* Store the last 2 places the queue element or head was altered */

/* QUEUE_MACRO_DEBUG */

/*
 * In C++ there can be structure lists and class lists:
 */

/*
 * Singly-linked List declarations.
 */

/* first element */

/* first element */

/* next element */

/* next element */

/*
 * Singly-linked List functions.
 */

/*
 * Singly-linked Tail queue declarations.
 */

/* first element */
/* addr of last next element */

/* first element */
/* addr of last next element */

/* next element */

/* next element */

/*
 * Singly-linked Tail queue functions.
 */

/*
 * List declarations.
 */

/* first element */

/* first element */

/* next element */
/* address of previous next element */

/* next element */
/* address of previous next element */

/*
 * List functions.
 */

/* (_KERNEL && INVARIANTS) */

/*
 * Tail queue declarations.
 */

/* first element */
/* addr of last next element */

/* first element */
/* addr of last next element */

/* next element */
/* address of previous next element */

/* next element */
/* address of previous next element */

/*
 * Tail queue functions.
 */

/* (_KERNEL && INVARIANTS) */

/* !_SYS_QUEUE_H_ */

/*
 * Copyright (c) 2014-2016 Cesanta Software Limited
 * All rights reserved
 */

/* ifdef-ok */

/* MQTT broker requires MQTT */

/* CS_MONGOOSE_SRC_FEATURES_H_ */

/*
 * Copyright (c) 2014-2016 Cesanta Software Limited
 * All rights reserved
 */

/* Amalgamated: #include "common/platform.h" */

/*
 * Internal async networking core interface.
 * Consists of calls made by the core, which should not block,
 * and callbacks back into the core ("..._cb").
 * Callbacks may (will) cause methods to be invoked from within,
 * but methods are not allowed to invoke callbacks inline.
 *
 * Implementation must ensure that only one callback is invoked at any time.
 */

/* __cplusplus */

struct mg_iface
{
    mg_mgr* mgr;
    void* data; /* Implementation-specific data */
    const(mg_iface_vtable)* vtable;
}

struct mg_iface_vtable
{
    void function (mg_iface* iface) init;
    void function (mg_iface* iface) free;
    void function (mg_connection* nc) add_conn;
    void function (mg_connection* nc) remove_conn;
    time_t function (mg_iface* iface, int timeout_ms) poll;

    /* Set up a listening TCP socket on a given address. rv = 0 -> ok. */
    int function (mg_connection* nc, socket_address* sa) listen_tcp;
    /* Request that a "listening" UDP socket be created. */
    int function (mg_connection* nc, socket_address* sa) listen_udp;

    /* Request that a TCP connection is made to the specified address. */
    void function (mg_connection* nc, const(socket_address)* sa) connect_tcp;
    /* Open a UDP socket. Doesn't actually connect anything. */
    void function (mg_connection* nc) connect_udp;

    /* Send functions for TCP and UDP. Sent data is copied before return. */
    int function (mg_connection* nc, const(void)* buf, size_t len) tcp_send;
    int function (mg_connection* nc, const(void)* buf, size_t len) udp_send;

    int function (mg_connection* nc, void* buf, size_t len) tcp_recv;
    int function (
        mg_connection* nc,
        void* buf,
        size_t len,
        socket_address* sa,
        size_t* sa_len) udp_recv;

    /* Perform interface-related connection initialization. Return 1 on ok. */
    int function (mg_connection* nc) create_conn;
    /* Perform interface-related cleanup on connection before destruction. */
    void function (mg_connection* nc) destroy_conn;

    /* Associate a socket to a connection. */
    void function (mg_connection* nc, sock_t sock) sock_set;

    /* Put connection's address into *sa, local (remote = 0) or remote. */
    void function (
        mg_connection* nc,
        int remote,
        socket_address* sa) get_conn_addr;
}

extern __gshared const(mg_iface_vtable)*[] mg_ifaces;
extern __gshared int mg_num_ifaces;

/* Creates a new interface instance. */
mg_iface* mg_if_create_iface (const(mg_iface_vtable)* vtable, mg_mgr* mgr);

/*
 * Find an interface with a given implementation. The search is started from
 * interface `from`, exclusive. Returns NULL if none is found.
 */
mg_iface* mg_find_iface (
    mg_mgr* mgr,
    const(mg_iface_vtable)* vtable,
    mg_iface* from);
/*
 * Deliver a new TCP connection. Returns NULL in case on error (unable to
 * create connection, in which case interface state should be discarded.
 * This is phase 1 of the two-phase process - MG_EV_ACCEPT will be delivered
 * when mg_if_accept_tcp_cb is invoked.
 */
mg_connection* mg_if_accept_new_conn (mg_connection* lc);
void mg_if_accept_tcp_cb (mg_connection* nc, socket_address* sa, size_t sa_len);

/* Callback invoked by connect methods. err = 0 -> ok, != 0 -> error. */
void mg_if_connect_cb (mg_connection* nc, int err);
/*
 * Callback that tells the core that data can be received.
 * Core will use tcp/udp_recv to retrieve the data.
 */
void mg_if_can_recv_cb (mg_connection* nc);
void mg_if_can_send_cb (mg_connection* nc);
/*
 * Receive callback.
 * buf must be heap-allocated and ownership is transferred to the core.
 */
void mg_if_recv_udp_cb (
    mg_connection* nc,
    void* buf,
    int len,
    socket_address* sa,
    size_t sa_len);

/* void mg_if_close_conn(struct mg_connection *nc); */

/* Deliver a POLL event to the connection. */
int mg_if_poll (mg_connection* nc, double now);

/*
 * Return minimal timer value amoung connections in the manager.
 * Returns 0 if there aren't any timers.
 */
double mg_mgr_min_timer (const(mg_mgr)* mgr);

/* __cplusplus */

/* CS_MONGOOSE_SRC_NET_IF_H_ */

/*
 * Copyright (c) 2014-2016 Cesanta Software Limited
 * All rights reserved
 */

/* __cplusplus */

/* __cplusplus */

/* MG_ENABLE_SSL */

/* CS_MONGOOSE_SRC_SSL_IF_H_ */

/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 * This software is dual-licensed: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation. For the terms of this
 * license, see <http://www.gnu.org/licenses/>.
 *
 * You are free to use this software under the terms of the GNU General
 * Public License, but WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * Alternatively, you can license this software under a commercial
 * license, as set out in <https://www.cesanta.com/license>.
 */

/*
 * === Core API: TCP/UDP/SSL
 *
 * NOTE: Mongoose manager is single threaded. It does not protect
 * its data structures by mutexes, therefore all functions that are dealing
 * with a particular event manager should be called from the same thread,
 * with exception of the `mg_broadcast()` function. It is fine to have different
 * event managers handled by different threads.
 */

/* Amalgamated: #include "mg_common.h" */
/* Amalgamated: #include "mg_net_if.h" */
/* Amalgamated: #include "common/mbuf.h" */

/* __cplusplus */

union socket_address
{
    sockaddr sa;
    sockaddr_in sin;

    sockaddr sin6;
}

/*
 * Callback function (event handler) prototype. Must be defined by the user.
 * Mongoose calls the event handler, passing the events defined below.
 */
alias mg_event_handler_t = void function (
    mg_connection* nc,
    int ev,
    void* ev_data);

/* Events. Meaning of event parameter (evp) is given in the comment. */
/* Sent to each connection on each mg_mgr_poll() call */
/* New connection accepted. union socket_address * */
/* connect() succeeded or failed. int *  */
/* Data has been received. int *num_bytes */
/* Data has been written to a socket. int *num_bytes */
/* Connection is closed. NULL */
/* now >= conn->ev_timer_time. double * */

/*
 * Mongoose event manager.
 */
struct mg_mgr
{
    mg_connection* active_connections;

    const(char)* hexdump_file; /* Debug hexdump file path */

    sock_t[2] ctl; /* Socketpair for mg_broadcast() */

    void* user_data; /* User data */
    int num_ifaces;
    int num_calls;
    mg_iface** ifaces; /* network interfaces */
    const(char)* nameserver; /* DNS server to use */
}

/*
 * Mongoose connection.
 */
struct mg_connection
{
    mg_connection* next;
    mg_connection* prev; /* mg_mgr::active_connections linkage */
    mg_connection* listener; /* Set only for accept()-ed connections */
    mg_mgr* mgr; /* Pointer to containing manager */

    sock_t sock; /* Socket to the remote peer */
    int err;
    socket_address sa; /* Remote peer address */
    size_t recv_mbuf_limit; /* Max size of recv buffer */
    mbuf recv_mbuf; /* Received data */
    mbuf send_mbuf; /* Data scheduled for sending */
    time_t last_io_time; /* Timestamp of the last socket IO */
    double ev_timer_time; /* Timestamp of the future MG_EV_TIMER */

    /* SSL library data. */

    mg_event_handler_t proto_handler; /* Protocol-specific event handler */
    void* proto_data; /* Protocol-specific data */
    void function (void* proto_data) proto_data_destructor;
    mg_event_handler_t handler; /* Event handler function */
    void* user_data; /* User-specific data */

    /*
     * the C standard is fussy about fitting function pointers into
     * void pointers, since some archs might have fat pointers for functions.
     */
    union _Anonymous_0
    {
        void* v;
        mg_event_handler_t f;
    }

    _Anonymous_0 priv_1;
    void* priv_2;
    void* mgr_data; /* Implementation-specific event manager's data. */
    mg_iface* iface;
    c_ulong flags;
    /* Flags set by Mongoose */
    /* This connection is listening */
    /* This connection is UDP */
    /* Waiting for async resolver */
    /* connect() call in progress */
    /* SSL is enabled on the connection */
    /* SSL hanshake has completed */
    /* SSL specific */
    /* SSL specific */
    /* Websocket specific */
    /* Drain rx and close the connection. */

    /* Flags that are settable by user */
    /* Push remaining data and close  */
    /* Disconnect */
    /* Websocket specific */
    /* HTTP specific */
    /* Allow broadcast address usage */

    /* Flags left for application */
}

/*
 * Initialise Mongoose manager. Side effect: ignores SIGPIPE signal.
 * `mgr->user_data` field will be initialised with a `user_data` parameter.
 * That is an arbitrary pointer, where the user code can associate some data
 * with the particular Mongoose manager. For example, a C++ wrapper class
 * could be written in which case `user_data` can hold a pointer to the
 * class instance.
 */
void mg_mgr_init (mg_mgr* mgr, void* user_data);

/*
 * Optional parameters to `mg_mgr_init_opt()`.
 *
 * If `main_iface` is not NULL, it will be used as the main interface in the
 * default interface set. The pointer will be free'd by `mg_mgr_free`.
 * Otherwise, the main interface will be autodetected based on the current
 * platform.
 *
 * If `num_ifaces` is 0 and `ifaces` is NULL, the default interface set will be
 * used.
 * This is an advanced option, as it requires you to construct a full interface
 * set, including special networking interfaces required by some optional
 * features such as TCP tunneling. Memory backing `ifaces` and each of the
 * `num_ifaces` pointers it contains will be reclaimed by `mg_mgr_free`.
 */
struct mg_mgr_init_opts
{
    const(mg_iface_vtable)* main_iface;
    int num_ifaces;
    const(mg_iface_vtable*)* ifaces;
    const(char)* nameserver;
}

/*
 * Like `mg_mgr_init` but with more options.
 *
 * Notably, this allows you to create a manger and choose
 * dynamically which networking interface implementation to use.
 */
void mg_mgr_init_opt (mg_mgr* mgr, void* user_data, mg_mgr_init_opts opts);

/*
 * De-initialises Mongoose manager.
 *
 * Closes and deallocates all active connections.
 */
void mg_mgr_free (mg_mgr* mgr);

/*
 * This function performs the actual IO and must be called in a loop
 * (an event loop). It returns number of user events generated (except POLLs).
 * `milli` is the maximum number of milliseconds to sleep.
 * `mg_mgr_poll()` checks all connections for IO readiness. If at least one
 * of the connections is IO-ready, `mg_mgr_poll()` triggers the respective
 * event handlers and returns.
 */
int mg_mgr_poll (mg_mgr* mgr, int milli);

/*
 * Passes a message of a given length to all connections.
 *
 * Must be called from a thread that does NOT call `mg_mgr_poll()`.
 * Note that `mg_broadcast()` is the only function
 * that can be, and must be, called from a different (non-IO) thread.
 *
 * `func` callback function will be called by the IO thread for each
 * connection. When called, the event will be `MG_EV_POLL`, and a message will
 * be passed as the `ev_data` pointer. Maximum message size is capped
 * by `MG_CTL_MSG_MESSAGE_SIZE` which is set to 8192 bytes by default.
 */
void mg_broadcast (mg_mgr* mgr, mg_event_handler_t cb, void* data, size_t len);

/*
 * Iterates over all active connections.
 *
 * Returns the next connection from the list
 * of active connections or `NULL` if there are no more connections. Below
 * is the iteration idiom:
 *
 * ```c
 * for (c = mg_next(srv, NULL); c != NULL; c = mg_next(srv, c)) {
 *   // Do something with connection `c`
 * }
 * ```
 */
mg_connection* mg_next (mg_mgr* mgr, mg_connection* c);

/*
 * Optional parameters to `mg_add_sock_opt()`.
 *
 * `flags` is an initial `struct mg_connection::flags` bitmask to set,
 * see `MG_F_*` flags definitions.
 */
struct mg_add_sock_opts
{
    void* user_data; /* Initial value for connection's user_data */
    uint flags; /* Initial connection flags */
    const(char*)* error_string; /* Placeholder for the error string */
    mg_iface* iface; /* Interface instance */
}

/*
 * Creates a connection, associates it with the given socket and event handler
 * and adds it to the manager.
 *
 * For more options see the `mg_add_sock_opt` variant.
 */
mg_connection* mg_add_sock (
    mg_mgr* mgr,
    sock_t sock,
    mg_event_handler_t handler);

/*
 * Creates a connection, associates it with the given socket and event handler
 * and adds to the manager.
 *
 * See the `mg_add_sock_opts` structure for a description of the options.
 */
mg_connection* mg_add_sock_opt (
    mg_mgr* mgr,
    sock_t sock,
    mg_event_handler_t handler,
    mg_add_sock_opts opts);

/*
 * Optional parameters to `mg_bind_opt()`.
 *
 * `flags` is an initial `struct mg_connection::flags` bitmask to set,
 * see `MG_F_*` flags definitions.
 */
struct mg_bind_opts
{
    void* user_data; /* Initial value for connection's user_data */
    uint flags; /* Extra connection flags */
    const(char*)* error_string; /* Placeholder for the error string */
    mg_iface* iface; /* Interface instance */

    /*
     * SSL settings.
     *
     * Server certificate to present to clients or client certificate to
     * present to tunnel dispatcher (for tunneled connections).
     */

    /* Private key corresponding to the certificate. If ssl_cert is set but
     * ssl_key is not, ssl_cert is used. */

    /* CA bundle used to verify client certificates or tunnel dispatchers. */

    /* Colon-delimited list of acceptable cipher suites.
     * Names depend on the library used, for example:
     *
     * ECDH-ECDSA-AES128-GCM-SHA256:DHE-RSA-AES128-SHA256 (OpenSSL)
     * TLS-ECDH-ECDSA-WITH-AES-128-GCM-SHA256:TLS-DHE-RSA-WITH-AES-128-GCM-SHA256
     *   (mbedTLS)
     *
     * For OpenSSL the list can be obtained by running "openssl ciphers".
     * For mbedTLS, names can be found in library/ssl_ciphersuites.c
     * If NULL, a reasonable default is used.
     */
}

/*
 * Creates a listening connection.
 *
 * See `mg_bind_opt` for full documentation.
 */
mg_connection* mg_bind (
    mg_mgr* mgr,
    const(char)* address,
    mg_event_handler_t handler);
/*
 * Creates a listening connection.
 *
 * The `address` parameter specifies which address to bind to. It's format is
 * the same as for the `mg_connect()` call, where `HOST` part is optional.
 * `address` can be just a port number, e.g. `:8000`. To bind to a specific
 * interface, an IP address can be specified, e.g. `1.2.3.4:8000`. By default,
 * a TCP connection is created. To create UDP connection, prepend `udp://`
 * prefix, e.g. `udp://:8000`. To summarize, `address` parameter has following
 * format: `[PROTO://][IP_ADDRESS]:PORT`, where `PROTO` could be `tcp` or
 * `udp`.
 *
 * See the `mg_bind_opts` structure for a description of the optional
 * parameters.
 *
 * Returns a new listening connection or `NULL` on error.
 * NOTE: The connection remains owned by the manager, do not free().
 */
mg_connection* mg_bind_opt (
    mg_mgr* mgr,
    const(char)* address,
    mg_event_handler_t handler,
    mg_bind_opts opts);

/* Optional parameters to `mg_connect_opt()` */
struct mg_connect_opts
{
    void* user_data; /* Initial value for connection's user_data */
    uint flags; /* Extra connection flags */
    const(char*)* error_string; /* Placeholder for the error string */
    mg_iface* iface; /* Interface instance */
    const(char)* nameserver; /* DNS server to use, NULL for default */

    /*
     * SSL settings.
     * Client certificate to present to the server.
     */

    /*
     * Private key corresponding to the certificate.
     * If ssl_cert is set but ssl_key is not, ssl_cert is used.
     */

    /*
     * Verify server certificate using this CA bundle. If set to "*", then SSL
     * is enabled but no cert verification is performed.
     */

    /* Colon-delimited list of acceptable cipher suites.
     * Names depend on the library used, for example:
     *
     * ECDH-ECDSA-AES128-GCM-SHA256:DHE-RSA-AES128-SHA256 (OpenSSL)
     * TLS-ECDH-ECDSA-WITH-AES-128-GCM-SHA256:TLS-DHE-RSA-WITH-AES-128-GCM-SHA256
     *   (mbedTLS)
     *
     * For OpenSSL the list can be obtained by running "openssl ciphers".
     * For mbedTLS, names can be found in library/ssl_ciphersuites.c
     * If NULL, a reasonable default is used.
     */

    /*
     * Server name verification. If ssl_ca_cert is set and the certificate has
     * passed verification, its subject will be verified against this string.
     * By default (if ssl_server_name is NULL) hostname part of the address will
     * be used. Wildcard matching is supported. A special value of "*" disables
     * name verification.
     */

    /*
     * PSK identity and key. Identity is a NUL-terminated string and key is a hex
     * string. Key must be either 16 or 32 bytes (32 or 64 hex digits) for AES-128
     * or AES-256 respectively.
     * Note: Default list of cipher suites does not include PSK suites, if you
     * want to use PSK you will need to set ssl_cipher_suites as well.
     */
}

/*
 * Connects to a remote host.
 *
 * See `mg_connect_opt()` for full documentation.
 */
mg_connection* mg_connect (
    mg_mgr* mgr,
    const(char)* address,
    mg_event_handler_t handler);

/*
 * Connects to a remote host.
 *
 * The `address` format is `[PROTO://]HOST:PORT`. `PROTO` could be `tcp` or
 * `udp`. `HOST` could be an IP address,
 * IPv6 address (if Mongoose is compiled with `-DMG_ENABLE_IPV6`) or a host
 * name. If `HOST` is a name, Mongoose will resolve it asynchronously. Examples
 * of valid addresses: `google.com:80`, `udp://1.2.3.4:53`, `10.0.0.1:443`,
 * `[::1]:80`
 *
 * See the `mg_connect_opts` structure for a description of the optional
 * parameters.
 *
 * Returns a new outbound connection or `NULL` on error.
 *
 * NOTE: The connection remains owned by the manager, do not free().
 *
 * NOTE: To enable IPv6 addresses `-DMG_ENABLE_IPV6` should be specified
 * in the compilation flags.
 *
 * NOTE: The new connection will receive `MG_EV_CONNECT` as its first event
 * which will report the connect success status.
 * If the asynchronous resolution fails or the `connect()` syscall fails for
 * whatever reason (e.g. with `ECONNREFUSED` or `ENETUNREACH`), then
 * `MG_EV_CONNECT` event will report failure. Code example below:
 *
 * ```c
 * static void ev_handler(struct mg_connection *nc, int ev, void *ev_data) {
 *   int connect_status;
 *
 *   switch (ev) {
 *     case MG_EV_CONNECT:
 *       connect_status = * (int *) ev_data;
 *       if (connect_status == 0) {
 *         // Success
 *       } else  {
 *         // Error
 *         printf("connect() error: %s\n", strerror(connect_status));
 *       }
 *       break;
 *     ...
 *   }
 * }
 *
 *   ...
 *   mg_connect(mgr, "my_site.com:80", ev_handler);
 * ```
 */
mg_connection* mg_connect_opt (
    mg_mgr* mgr,
    const(char)* address,
    mg_event_handler_t handler,
    mg_connect_opts opts);

/*
 * Note: This function is deprecated. Please, use SSL options in
 * mg_connect_opt.
 *
 * Enables SSL for a given connection.
 * `cert` is a server certificate file name for a listening connection
 * or a client certificate file name for an outgoing connection.
 * The certificate files must be in PEM format. The server certificate file
 * must contain a certificate, concatenated with a private key, optionally
 * concatenated with DH parameters.
 * `ca_cert` is a CA certificate or NULL if peer verification is not
 * required.
 * Return: NULL on success or error message on error.
 */

/*
 * Sends data to the connection.
 *
 * Note that sending functions do not actually push data to the socket.
 * They just append data to the output buffer. MG_EV_SEND will be delivered when
 * the data has actually been pushed out.
 */
void mg_send (mg_connection*, const(void)* buf, int len);

/* Enables format string warnings for mg_printf */

/* don't separate from mg_printf declaration */

/*
 * Sends `printf`-style formatted data to the connection.
 *
 * See `mg_send` for more details on send semantics.
 */
int mg_printf (mg_connection*, const(char)* fmt, ...);

/* Same as `mg_printf()`, but takes `va_list ap` as an argument. */
int mg_vprintf (mg_connection*, const(char)* fmt, ...);

/*
 * Creates a socket pair.
 * `sock_type` can be either `SOCK_STREAM` or `SOCK_DGRAM`.
 * Returns 0 on failure and 1 on success.
 */
int mg_socketpair (ref sock_t[2], int sock_type);

/*
 * Convert domain name into IP address.
 *
 * This is a utility function. If compilation flags have
 * `-DMG_ENABLE_GETADDRINFO`, then `getaddrinfo()` call is used for name
 * resolution. Otherwise, `gethostbyname()` is used.
 *
 * CAUTION: this function can block.
 * Return 1 on success, 0 on failure.
 */

/*
 * Verify given IP address against the ACL.
 *
 * `remote_ip` - an IPv4 address to check, in host byte order
 * `acl` - a comma separated list of IP subnets: `x.x.x.x/x` or `x.x.x.x`.
 * Each subnet is
 * prepended by either a - or a + sign. A plus sign means allow, where a
 * minus sign means deny. If a subnet mask is omitted, such as `-1.2.3.4`,
 * it means that only that single IP address is denied.
 * Subnet masks may vary from 0 to 32, inclusive. The default setting
 * is to allow all access. On each request the full list is traversed,
 * and the last match wins. Example:
 *
 * `-0.0.0.0/0,+192.168/16` - deny all accesses, only allow 192.168/16 subnet
 *
 * To learn more about subnet masks, see this
 * link:https://en.wikipedia.org/wiki/Subnetwork[Wikipedia page on Subnetwork].
 *
 * Returns -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.
 */
int mg_check_ip_acl (const(char)* acl, uint remote_ip);

/*
 * Schedules an MG_EV_TIMER event to be delivered at `timestamp` time.
 * `timestamp` is UNIX time (the number of seconds since Epoch). It is
 * `double` instead of `time_t` to allow for sub-second precision.
 * Returns the old timer value.
 *
 * Example: set the connect timeout to 1.5 seconds:
 *
 * ```
 *  c = mg_connect(&mgr, "cesanta.com", ev_handler);
 *  mg_set_timer(c, mg_time() + 1.5);
 *  ...
 *
 *  void ev_handler(struct mg_connection *c, int ev, void *ev_data) {
 *  switch (ev) {
 *    case MG_EV_CONNECT:
 *      mg_set_timer(c, 0);  // Clear connect timer
 *      break;
 *    case MG_EV_TIMER:
 *      log("Connect timeout");
 *      c->flags |= MG_F_CLOSE_IMMEDIATELY;
 *      break;
 * ```
 */
double mg_set_timer (mg_connection* c, double timestamp);

/*
 * A sub-second precision version of time().
 */
double mg_time ();

/* __cplusplus */

/* CS_MONGOOSE_SRC_NET_H_ */

/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */

/*
 * === URI
 */

/* Amalgamated: #include "mg_net.h" */

/* __cplusplus */

/*
 * Parses an URI and fills string chunks with locations of the respective
 * uri components within the input uri string. NULL pointers will be
 * ignored.
 *
 * General syntax:
 *
 *     [scheme://[user_info@]]host[:port][/path][?query][#fragment]
 *
 * Example:
 *
 *     foo.com:80
 *     tcp://foo.com:1234
 *     http://foo.com:80/bar?baz=1
 *     https://user:pw@foo.com:443/blah
 *
 * `path` will include the leading slash. `query` won't include the leading `?`.
 * `host` can contain embedded colons if surrounded by square brackets in order
 * to support IPv6 literal addresses.
 *
 *
 * Returns 0 on success, -1 on error.
 */
int mg_parse_uri (
    const mg_str uri,
    mg_str* scheme,
    mg_str* user_info,
    mg_str* host,
    uint* port,
    mg_str* path,
    mg_str* query,
    mg_str* fragment);

/*
 * Assemble URI from parts. Any of the inputs can be NULL or zero-length mg_str.
 *
 * If normalize_path is true, path is normalized by resolving relative refs.
 *
 * Result is a heap-allocated string (uri->p must be free()d after use).
 *
 * Returns 0 on success, -1 on error.
 */
int mg_assemble_uri (
    const(mg_str)* scheme,
    const(mg_str)* user_info,
    const(mg_str)* host,
    uint port,
    const(mg_str)* path,
    const(mg_str)* query,
    const(mg_str)* fragment,
    int normalize_path,
    mg_str* uri);

int mg_normalize_uri_path (const(mg_str)* in_, mg_str* out_);

/* __cplusplus */
/* CS_MONGOOSE_SRC_URI_H_ */

/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */

/*
 * === Utility API
 */

/* Amalgamated: #include "mg_common.h" */
/* Amalgamated: #include "mg_net_if.h" */

/* __cplusplus */

/*
 * Fetches substring from input string `s`, `end` into `v`.
 * Skips initial delimiter characters. Records first non-delimiter character
 * at the beginning of substring `v`. Then scans the rest of the string
 * until a delimiter character or end-of-string is found.
 * `delimiters` is a 0-terminated string containing delimiter characters.
 * Either one of `delimiters` or `end_string` terminates the search.
 * Returns an `s` pointer, advanced forward where parsing has stopped.
 */
const(char)* mg_skip (
    const(char)* s,
    const(char)* end_string,
    const(char)* delimiters,
    mg_str* v);

/*
 * Decodes base64-encoded string `s`, `len` into the destination `dst`.
 * The destination has to have enough space to hold the decoded buffer.
 * Decoding stops either when all strings have been decoded or invalid an
 * character appeared.
 * Destination is '\0'-terminated.
 * Returns the number of decoded characters. On success, that should be equal
 * to `len`. On error (invalid character) the return value is smaller then
 * `len`.
 */
int mg_base64_decode (const(ubyte)* s, int len, char* dst);

/*
 * Base64-encode chunk of memory `src`, `src_len` into the destination `dst`.
 * Destination has to have enough space to hold encoded buffer.
 * Destination is '\0'-terminated.
 */
void mg_base64_encode (const(ubyte)* src, int src_len, char* dst);

/*
 * Performs a 64-bit `stat()` call against a given file.
 *
 * `path` should be UTF8 encoded.
 *
 * Return value is the same as for `stat()` syscall.
 */
int mg_stat (const(char)* path, cs_stat_t* st);

/*
 * Opens the given file and returns a file stream.
 *
 * `path` and `mode` should be UTF8 encoded.
 *
 * Return value is the same as for the `fopen()` call.
 */
FILE* mg_fopen (const(char)* path, const(char)* mode);

/*
 * Opens the given file and returns a file stream.
 *
 * `path` should be UTF8 encoded.
 *
 * Return value is the same as for the `open()` syscall.
 */
int mg_open (const(char)* path, int flag, int mode);

/*
 * Reads data from the given file stream.
 *
 * Return value is a number of bytes readen.
 */
size_t mg_fread (void* ptr, size_t size, size_t count, FILE* f);

/*
 * Writes data to the given file stream.
 *
 * Return value is a number of bytes wtitten.
 */
size_t mg_fwrite (const(void)* ptr, size_t size, size_t count, FILE* f);

/* MG_ENABLE_FILESYSTEM */

/*
 * Starts a new detached thread.
 * Arguments and semantics are the same as pthead's `pthread_create()`.
 * `thread_func` is a thread function, `thread_func_param` is a parameter
 * that is passed to the thread function.
 */

void mg_set_close_on_exec (sock_t);

/*
 * Converts a connection's local or remote address into string.
 *
 * The `flags` parameter is a bit mask that controls the behaviour,
 * see `MG_SOCK_STRINGIFY_*` definitions.
 *
 * - MG_SOCK_STRINGIFY_IP - print IP address
 * - MG_SOCK_STRINGIFY_PORT - print port number
 * - MG_SOCK_STRINGIFY_REMOTE - print remote peer's IP/port, not local address
 *
 * If both port number and IP address are printed, they are separated by `:`.
 * If compiled with `-DMG_ENABLE_IPV6`, IPv6 addresses are supported.
 * Return length of the stringified address.
 */
int mg_conn_addr_to_str (mg_connection* c, char* buf, size_t len, int flags);

/* Legacy interface. */
void mg_sock_to_str (sock_t sock, char* buf, size_t len, int flags);

/*
 * Convert the socket's address into string.
 *
 * `flags` is MG_SOCK_STRINGIFY_IP and/or MG_SOCK_STRINGIFY_PORT.
 */
int mg_sock_addr_to_str (
    const(socket_address)* sa,
    char* buf,
    size_t len,
    int flags);

/*
 * Generates a human-readable hexdump of memory chunk.
 *
 * Takes a memory buffer `buf` of length `len` and creates a hex dump of that
 * buffer in `dst`. The generated output is a-la hexdump(1).
 * Returns the length of generated string, excluding terminating `\0`. If
 * returned length is bigger than `dst_len`, the overflow bytes are discarded.
 */
int mg_hexdump (const(void)* buf, int len, char* dst, int dst_len);

/* Same as mg_hexdump, but with output going to file instead of a buffer. */
void mg_hexdumpf (FILE* fp, const(void)* buf, int len);

/*
 * Generates human-readable hexdump of the data sent or received by the
 * connection. `path` is a file name where hexdump should be written.
 * `num_bytes` is a number of bytes sent/received. `ev` is one of the `MG_*`
 * events sent to an event handler. This function is supposed to be called from
 * the event handler.
 */
void mg_hexdump_connection (
    mg_connection* nc,
    const(char)* path,
    const(void)* buf,
    int num_bytes,
    int ev);

/*
 * Returns true if target platform is big endian.
 */
int mg_is_big_endian ();

/*
 * Use with cs_base64_init/update/finish in order to write out base64 in chunks.
 */
void mg_mbuf_append_base64_putc (char ch, void* user_data);

/*
 * Encode `len` bytes starting at `data` as base64 and append them to an mbuf.
 */
void mg_mbuf_append_base64 (mbuf* mbuf, const(void)* data, size_t len);

/*
 * Generate a Basic Auth header and appends it to buf.
 * If pass is NULL, then user is expected to contain the credentials pair
 * already encoded as `user:pass`.
 */
void mg_basic_auth_header (const mg_str user, const mg_str pass, mbuf* buf);

/*
 * URL-escape the specified string.
 * All characters acept letters, numbers and characters listed in
 * `safe` are escaped. If `hex_upper`is true, `A-F` are used for hex digits.
 * Input need not be NUL-terminated, but the returned string is.
 * Returned string is heap-allocated and must be free()'d.
 */

mg_str mg_url_encode_opt (const mg_str src, const mg_str safe, uint flags);

/* Same as `mg_url_encode_opt(src, "._-$,;~()/", 0)`. */
mg_str mg_url_encode (const mg_str src);

/* __cplusplus */
/* CS_MONGOOSE_SRC_UTIL_H_ */

/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */

/*
 * === Common API reference
 */

/* Amalgamated: #include "mg_net.h" */
/* Amalgamated: #include "common/mg_str.h" */

/* __cplusplus */

/* HTTP message */
struct http_message
{
    mg_str message; /* Whole message: request line + headers + body */
    mg_str body_; /* Message body. 0-length for requests with no body */

    /* HTTP Request line (or HTTP response line) */
    mg_str method; /* "GET" */
    mg_str uri; /* "/my_file.html" */
    mg_str proto; /* "HTTP/1.1" -- for both request and response */

    /* For responses, code and response status message are set */
    int resp_code;
    mg_str resp_status_msg;

    /*
     * Query-string part of the URI. For example, for HTTP request
     *    GET /foo/bar?param1=val1&param2=val2
     *    |    uri    |     query_string     |
     *
     * Note that question mark character doesn't belong neither to the uri,
     * nor to the query_string
     */
    mg_str query_string;

    /* Headers */
    mg_str[MG_MAX_HTTP_HEADERS] header_names;
    mg_str[MG_MAX_HTTP_HEADERS] header_values;
}

/* WebSocket message */
struct websocket_message
{
    ubyte* data;
    size_t size;
    ubyte flags;
}

/* HTTP multipart part */
struct mg_http_multipart_part
{
    const(char)* file_name;
    const(char)* var_name;
    mg_str data;
    int status; /* <0 on error */
    void* user_data;
    /*
     * User handler can indicate how much of the data was consumed
     * by setting this variable. By default, it is assumed that all
     * data has been consumed by the handler.
     * If not all data was consumed, user's handler will be invoked again later
     * with the remainder.
     */
    size_t num_data_consumed;
}

/* SSI call context */
struct mg_ssi_call_ctx
{
    http_message* req; /* The request being processed. */
    mg_str file; /* Filesystem path of the file being processed. */
    mg_str arg; /* The argument passed to the tag: <!-- call arg -->. */
}

/* HTTP and websocket events. void *ev_data is described in a comment. */
/* struct http_message * */
/* struct http_message * */
/* struct http_message * */
/* char * */
/* struct mg_ssi_call_ctx * */

/* struct http_message * */
/* struct http_message * */
/* struct websocket_message * */
/* struct websocket_message * */

/* struct http_message */
/* struct mg_http_multipart_part */
/* struct mg_http_multipart_part */
/* struct mg_http_multipart_part */
/* struct mg_http_multipart_part */

/*
 * Attaches a built-in HTTP event handler to the given connection.
 * The user-defined event handler will receive following extra events:
 *
 * - MG_EV_HTTP_REQUEST: HTTP request has arrived. Parsed HTTP request
 *  is passed as
 *   `struct http_message` through the handler's `void *ev_data` pointer.
 * - MG_EV_HTTP_REPLY: The HTTP reply has arrived. The parsed HTTP reply is
 *   passed as `struct http_message` through the handler's `void *ev_data`
 *   pointer.
 * - MG_EV_HTTP_CHUNK: The HTTP chunked-encoding chunk has arrived.
 *   The parsed HTTP reply is passed as `struct http_message` through the
 *   handler's `void *ev_data` pointer. `http_message::body` would contain
 *   incomplete, reassembled HTTP body.
 *   It will grow with every new chunk that arrives, and it can
 *   potentially consume a lot of memory. An event handler may process
 *   the body as chunks are coming, and signal Mongoose to delete processed
 *   body by setting `MG_F_DELETE_CHUNK` in `mg_connection::flags`. When
 *   the last zero chunk is received,
 *   Mongoose sends `MG_EV_HTTP_REPLY` event with
 *   full reassembled body (if handler did not signal to delete chunks) or
 *   with empty body (if handler did signal to delete chunks).
 * - MG_EV_WEBSOCKET_HANDSHAKE_REQUEST: server has received the WebSocket
 *   handshake request. `ev_data` contains parsed HTTP request.
 * - MG_EV_WEBSOCKET_HANDSHAKE_DONE: server has completed the WebSocket
 *   handshake. `ev_data` is a `struct http_message` containing the
 *   client's request (server mode) or server's response (client).
 *   In client mode handler can examine `resp_code`, which should be 101.
 * - MG_EV_WEBSOCKET_FRAME: new WebSocket frame has arrived. `ev_data` is
 *   `struct websocket_message *`
 *
 * When compiled with MG_ENABLE_HTTP_STREAMING_MULTIPART, Mongoose parses
 * multipart requests and splits them into separate events:
 * - MG_EV_HTTP_MULTIPART_REQUEST: Start of the request.
 *   This event is sent before body is parsed. After this, the user
 *   should expect a sequence of PART_BEGIN/DATA/END requests.
 *   This is also the last time when headers and other request fields are
 *   accessible.
 * - MG_EV_HTTP_PART_BEGIN: Start of a part of a multipart message.
 *   Argument: mg_http_multipart_part with var_name and file_name set
 *   (if present). No data is passed in this message.
 * - MG_EV_HTTP_PART_DATA: new portion of data from the multipart message.
 *   Argument: mg_http_multipart_part. var_name and file_name are preserved,
 *   data is available in mg_http_multipart_part.data.
 * - MG_EV_HTTP_PART_END: End of the current part. var_name, file_name are
 *   the same, no data in the message. If status is 0, then the part is
 *   properly terminated with a boundary, status < 0 means that connection
 *   was terminated.
 * - MG_EV_HTTP_MULTIPART_REQUEST_END: End of the multipart request.
 *   Argument: mg_http_multipart_part, var_name and file_name are NULL,
 *   status = 0 means request was properly closed, < 0 means connection
 *   was terminated (note: in this case both PART_END and REQUEST_END are
 *   delivered).
 */
void mg_set_protocol_http_websocket (mg_connection* nc);

/*
 * Send websocket handshake to the server.
 *
 * `nc` must be a valid connection, connected to a server. `uri` is an URI
 * to fetch, extra_headers` is extra HTTP headers to send or `NULL`.
 *
 * This function is intended to be used by websocket client.
 *
 * Note that the Host header is mandatory in HTTP/1.1 and must be
 * included in `extra_headers`. `mg_send_websocket_handshake2` offers
 * a better API for that.
 *
 * Deprecated in favour of `mg_send_websocket_handshake2`
 */
void mg_send_websocket_handshake (
    mg_connection* nc,
    const(char)* uri,
    const(char)* extra_headers);

/*
 * Send websocket handshake to the server.
 *
 * `nc` must be a valid connection, connected to a server. `uri` is an URI
 * to fetch, `host` goes into the `Host` header, `protocol` goes into the
 * `Sec-WebSocket-Proto` header (NULL to omit), extra_headers` is extra HTTP
 * headers to send or `NULL`.
 *
 * This function is intended to be used by websocket client.
 */
void mg_send_websocket_handshake2 (
    mg_connection* nc,
    const(char)* path,
    const(char)* host,
    const(char)* protocol,
    const(char)* extra_headers);

/* Like mg_send_websocket_handshake2 but also passes basic auth header */
void mg_send_websocket_handshake3 (
    mg_connection* nc,
    const(char)* path,
    const(char)* host,
    const(char)* protocol,
    const(char)* extra_headers,
    const(char)* user,
    const(char)* pass);

/* Same as mg_send_websocket_handshake3 but with strings not necessarily
 * NUL-temrinated */
void mg_send_websocket_handshake3v (
    mg_connection* nc,
    const mg_str path,
    const mg_str host,
    const mg_str protocol,
    const mg_str extra_headers,
    const mg_str user,
    const mg_str pass);

/*
 * Helper function that creates an outbound WebSocket connection.
 *
 * `url` is a URL to connect to. It must be properly URL-encoded, e.g. have
 * no spaces, etc. By default, `mg_connect_ws()` sends Connection and
 * Host headers. `extra_headers` is an extra HTTP header to send, e.g.
 * `"User-Agent: my-app\r\n"`.
 * If `protocol` is not NULL, then a `Sec-WebSocket-Protocol` header is sent.
 *
 * Examples:
 *
 * ```c
 *   nc1 = mg_connect_ws(mgr, ev_handler_1, "ws://echo.websocket.org", NULL,
 *                       NULL);
 *   nc2 = mg_connect_ws(mgr, ev_handler_1, "wss://echo.websocket.org", NULL,
 *                       NULL);
 *   nc3 = mg_connect_ws(mgr, ev_handler_1, "ws://api.cesanta.com",
 *                       "clubby.cesanta.com", NULL);
 * ```
 */
mg_connection* mg_connect_ws (
    mg_mgr* mgr,
    mg_event_handler_t event_handler,
    const(char)* url,
    const(char)* protocol,
    const(char)* extra_headers);

/*
 * Helper function that creates an outbound WebSocket connection
 *
 * Mostly identical to `mg_connect_ws`, but allows to provide extra parameters
 * (for example, SSL parameters)
 */
mg_connection* mg_connect_ws_opt (
    mg_mgr* mgr,
    mg_event_handler_t ev_handler,
    mg_connect_opts opts,
    const(char)* url,
    const(char)* protocol,
    const(char)* extra_headers);

/*
 * Send WebSocket frame to the remote end.
 *
 * `op_and_flags` specifies the frame's type. It's one of:
 *
 * - WEBSOCKET_OP_CONTINUE
 * - WEBSOCKET_OP_TEXT
 * - WEBSOCKET_OP_BINARY
 * - WEBSOCKET_OP_CLOSE
 * - WEBSOCKET_OP_PING
 * - WEBSOCKET_OP_PONG
 *
 * Orred with one of the flags:
 *
 * - WEBSOCKET_DONT_FIN: Don't set the FIN flag on the frame to be sent.
 *
 * `data` and `data_len` contain frame data.
 */
void mg_send_websocket_frame (
    mg_connection* nc,
    int op_and_flags,
    const(void)* data,
    size_t data_len);

/*
 * Like `mg_send_websocket_frame()`, but composes a single frame from multiple
 * buffers.
 */
void mg_send_websocket_framev (
    mg_connection* nc,
    int op_and_flags,
    const(mg_str)* strings,
    int num_strings);

/*
 * Sends WebSocket frame to the remote end.
 *
 * Like `mg_send_websocket_frame()`, but allows to create formatted messages
 * with `printf()`-like semantics.
 */
void mg_printf_websocket_frame (
    mg_connection* nc,
    int op_and_flags,
    const(char)* fmt,
    ...);

/* Websocket opcodes, from http://tools.ietf.org/html/rfc6455 */

/*
 * If set causes the FIN flag to not be set on outbound
 * frames. This enables sending multiple fragments of a single
 * logical message.
 *
 * The WebSocket protocol mandates that if the FIN flag of a data
 * frame is not set, the next frame must be a WEBSOCKET_OP_CONTINUE.
 * The last frame must have the FIN bit set.
 *
 * Note that mongoose will automatically defragment incoming messages,
 * so this flag is used only on outbound messages.
 */

/* MG_ENABLE_HTTP_WEBSOCKET */

/*
 * Decodes a URL-encoded string.
 *
 * Source string is specified by (`src`, `src_len`), and destination is
 * (`dst`, `dst_len`). If `is_form_url_encoded` is non-zero, then
 * `+` character is decoded as a blank space character. This function
 * guarantees to NUL-terminate the destination. If destination is too small,
 * then the source string is partially decoded and `-1` is returned.
 *Otherwise,
 * a length of the decoded string is returned, not counting final NUL.
 */
int mg_url_decode (
    const(char)* src,
    int src_len,
    char* dst,
    int dst_len,
    int is_form_url_encoded);

void mg_hash_md5_v (
    size_t num_msgs,
    const(ubyte)** msgs,
    const(size_t)* msg_lens,
    ubyte* digest);
void mg_hash_sha1_v (
    size_t num_msgs,
    const(ubyte)** msgs,
    const(size_t)* msg_lens,
    ubyte* digest);

/*
 * Flags for `mg_http_is_authorized()`.
 */

/*
 * Checks whether an http request is authorized. `domain` is the authentication
 * realm, `passwords_file` is a htdigest file (can be created e.g. with
 * `htdigest` utility). If either `domain` or `passwords_file` is NULL, this
 * function always returns 1; otherwise checks the authentication in the
 * http request and returns 1 only if there is a match; 0 otherwise.
 */
int mg_http_is_authorized (
    http_message* hm,
    mg_str path,
    const(char)* domain,
    const(char)* passwords_file,
    int flags);

/*
 * Sends 401 Unauthorized response.
 */
void mg_http_send_digest_auth_request (mg_connection* c, const(char)* domain);

/* __cplusplus */

/* MG_ENABLE_HTTP */

/* CS_MONGOOSE_SRC_HTTP_H_ */

/*
 * === Server API reference
 */

/* __cplusplus */

/*
 * Parses a HTTP message.
 *
 * `is_req` should be set to 1 if parsing a request, 0 if reply.
 *
 * Returns the number of bytes parsed. If HTTP message is
 * incomplete `0` is returned. On parse error, a negative number is returned.
 */
int mg_parse_http (const(char)* s, int n, http_message* hm, int is_req);

/*
 * Searches and returns the header `name` in parsed HTTP message `hm`.
 * If header is not found, NULL is returned. Example:
 *
 *     struct mg_str *host_hdr = mg_get_http_header(hm, "Host");
 */
mg_str* mg_get_http_header (http_message* hm, const(char)* name);

/*
 * Parses the HTTP header `hdr`. Finds variable `var_name` and stores its value
 * in the buffer `*buf`, `buf_size`. If the buffer size is not enough,
 * allocates a buffer of required size and writes it to `*buf`, similar to
 * asprintf(). The caller should always check whether the buffer was updated,
 * and free it if so.
 *
 * This function is supposed to parse cookies, authentication headers, etc.
 * Example (error handling omitted):
 *
 *     char user_buf[20];
 *     char *user = user_buf;
 *     struct mg_str *hdr = mg_get_http_header(hm, "Authorization");
 *     mg_http_parse_header2(hdr, "username", &user, sizeof(user_buf));
 *     // ... do something useful with user
 *     if (user != user_buf) {
 *       free(user);
 *     }
 *
 * Returns the length of the variable's value. If variable is not found, 0 is
 * returned.
 */
int mg_http_parse_header2 (
    mg_str* hdr,
    const(char)* var_name,
    char** buf,
    size_t buf_size);

/*
 * DEPRECATED: use mg_http_parse_header2() instead.
 *
 * Same as mg_http_parse_header2(), but takes buffer as a `char *` (instead of
 * `char **`), and thus it cannot allocate a new buffer if the provided one
 * is not enough, and just returns 0 in that case.
 */
int mg_http_parse_header (
    mg_str* hdr,
    const(char)* var_name,
    char* buf,
    size_t buf_size);

/*
 * Gets and parses the Authorization: Basic header
 * Returns -1 if no Authorization header is found, or if
 * mg_parse_http_basic_auth
 * fails parsing the resulting header.
 */
int mg_get_http_basic_auth (
    http_message* hm,
    char* user,
    size_t user_len,
    char* pass,
    size_t pass_len);

/*
 * Parses the Authorization: Basic header
 * Returns -1 iif the authorization type is not "Basic" or any other error such
 * as incorrectly encoded base64 user password pair.
 */
int mg_parse_http_basic_auth (
    mg_str* hdr,
    char* user,
    size_t user_len,
    char* pass,
    size_t pass_len);

/*
 * Parses the buffer `buf`, `buf_len` that contains multipart form data chunks.
 * Stores the chunk name in a `var_name`, `var_name_len` buffer.
 * If a chunk is an uploaded file, then `file_name`, `file_name_len` is
 * filled with an uploaded file name. `chunk`, `chunk_len`
 * points to the chunk data.
 *
 * Return: number of bytes to skip to the next chunk or 0 if there are
 *         no more chunks.
 *
 * Usage example:
 *
 * ```c
 *    static void ev_handler(struct mg_connection *nc, int ev, void *ev_data) {
 *      switch(ev) {
 *        case MG_EV_HTTP_REQUEST: {
 *          struct http_message *hm = (struct http_message *) ev_data;
 *          char var_name[100], file_name[100];
 *          const char *chunk;
 *          size_t chunk_len, n1, n2;
 *
 *          n1 = n2 = 0;
 *          while ((n2 = mg_parse_multipart(hm->body.p + n1,
 *                                          hm->body.len - n1,
 *                                          var_name, sizeof(var_name),
 *                                          file_name, sizeof(file_name),
 *                                          &chunk, &chunk_len)) > 0) {
 *            printf("var: %s, file_name: %s, size: %d, chunk: [%.*s]\n",
 *                   var_name, file_name, (int) chunk_len,
 *                   (int) chunk_len, chunk);
 *            n1 += n2;
 *          }
 *        }
 *        break;
 * ```
 */
size_t mg_parse_multipart (
    const(char)* buf,
    size_t buf_len,
    char* var_name,
    size_t var_name_len,
    char* file_name,
    size_t file_name_len,
    const(char*)* chunk,
    size_t* chunk_len);

/*
 * Fetches a HTTP form variable.
 *
 * Fetches a variable `name` from a `buf` into a buffer specified by `dst`,
 * `dst_len`. The destination is always zero-terminated. Returns the length of
 * a fetched variable. If not found, 0 is returned. `buf` must be valid
 * url-encoded buffer. If destination is too small or an error occured,
 * negative number is returned.
 */
int mg_get_http_var (
    const(mg_str)* buf,
    const(char)* name,
    char* dst,
    size_t dst_len);

/*
 * This structure defines how `mg_serve_http()` works.
 * Best practice is to set only required settings, and leave the rest as NULL.
 */
struct mg_serve_http_opts
{
    /* Path to web root directory */
    const(char)* document_root;

    /* List of index files. Default is "" */
    const(char)* index_files;

    /*
     * Leave as NULL to disable authentication.
     * To enable directory protection with authentication, set this to ".htpasswd"
     * Then, creating ".htpasswd" file in any directory automatically protects
     * it with digest authentication.
     * Use `mongoose` web server binary, or `htdigest` Apache utility to
     * create/manipulate passwords file.
     * Make sure `auth_domain` is set to a valid domain name.
     */
    const(char)* per_directory_auth_file;

    /* Authorization domain (domain name of this web server) */
    const(char)* auth_domain;

    /*
     * Leave as NULL to disable authentication.
     * Normally, only selected directories in the document root are protected.
     * If absolutely every access to the web server needs to be authenticated,
     * regardless of the URI, set this option to the path to the passwords file.
     * Format of that file is the same as ".htpasswd" file. Make sure that file
     * is located outside document root to prevent people fetching it.
     */
    const(char)* global_auth_file;

    /* Set to "no" to disable directory listing. Enabled by default. */
    const(char)* enable_directory_listing;

    /*
     * SSI files pattern. If not set, "**.shtml$|**.shtm$" is used.
     *
     * All files that match ssi_pattern are treated as SSI.
     *
     * Server Side Includes (SSI) is a simple interpreted server-side scripting
     * language which is most commonly used to include the contents of a file
     * into a web page. It can be useful when it is desirable to include a common
     * piece of code throughout a website, for example, headers and footers.
     *
     * In order for a webpage to recognize an SSI-enabled HTML file, the
     * filename should end with a special extension, by default the extension
     * should be either .shtml or .shtm
     *
     * Unknown SSI directives are silently ignored by Mongoose. Currently,
     * the following SSI directives are supported:
     *    &lt;!--#include FILE_TO_INCLUDE --&gt;
     *    &lt;!--#exec "COMMAND_TO_EXECUTE" --&gt;
     *    &lt;!--#call COMMAND --&gt;
     *
     * Note that &lt;!--#include ...> directive supports three path
     *specifications:
     *
     * &lt;!--#include virtual="path" --&gt;  Path is relative to web server root
     * &lt;!--#include abspath="path" --&gt;  Path is absolute or relative to the
     *                                  web server working dir
     * &lt;!--#include file="path" --&gt;,    Path is relative to current document
     * &lt;!--#include "path" --&gt;
     *
     * The include directive may be used to include the contents of a file or
     * the result of running a CGI script.
     *
     * The exec directive is used to execute
     * a command on a server, and show command's output. Example:
     *
     * &lt;!--#exec "ls -l" --&gt;
     *
     * The call directive is a way to invoke a C handler from the HTML page.
     * On each occurence of &lt;!--#call COMMAND OPTIONAL_PARAMS> directive,
     * Mongoose calls a registered event handler with MG_EV_SSI_CALL event,
     * and event parameter will point to the COMMAND OPTIONAL_PARAMS string.
     * An event handler can output any text, for example by calling
     * `mg_printf()`. This is a flexible way of generating a web page on
     * server side by calling a C event handler. Example:
     *
     * &lt;!--#call foo --&gt; ... &lt;!--#call bar --&gt;
     *
     * In the event handler:
     *    case MG_EV_SSI_CALL: {
     *      const char *param = (const char *) ev_data;
     *      if (strcmp(param, "foo") == 0) {
     *        mg_printf(c, "hello from foo");
     *      } else if (strcmp(param, "bar") == 0) {
     *        mg_printf(c, "hello from bar");
     *      }
     *      break;
     *    }
     */
    const(char)* ssi_pattern;

    /* IP ACL. By default, NULL, meaning all IPs are allowed to connect */
    const(char)* ip_acl;

    /* URL rewrites.
     *
     * Comma-separated list of `uri_pattern=url_file_or_directory_path` rewrites.
     * When HTTP request is received, Mongoose constructs a file name from the
     * requested URI by combining `document_root` and the URI. However, if the
     * rewrite option is used and `uri_pattern` matches requested URI, then
     * `document_root` is ignored. Instead, `url_file_or_directory_path` is used,
     * which should be a full path name or a path relative to the web server's
     * current working directory. It can also be an URI (http:// or https://)
     * in which case mongoose will behave as a reverse proxy for that destination.
     *
     * Note that `uri_pattern`, as all Mongoose patterns, is a prefix pattern.
     *
     * If uri_pattern starts with `@` symbol, then Mongoose compares it with the
     * HOST header of the request. If they are equal, Mongoose sets document root
     * to `file_or_directory_path`, implementing virtual hosts support.
     * Example: `@foo.com=/document/root/for/foo.com`
     *
     * If `uri_pattern` starts with `%` symbol, then Mongoose compares it with
     * the listening port. If they match, then Mongoose issues a 301 redirect.
     * For example, to redirect all HTTP requests to the
     * HTTPS port, do `%80=https://my.site.com`. Note that the request URI is
     * automatically appended to the redirect location.
     */
    const(char)* url_rewrites;

    /* DAV document root. If NULL, DAV requests are going to fail. */
    const(char)* dav_document_root;

    /*
     * DAV passwords file. If NULL, DAV requests are going to fail.
     * If passwords file is set to "-", then DAV auth is disabled.
     */
    const(char)* dav_auth_file;

    /* Glob pattern for the files to hide. */
    const(char)* hidden_file_pattern;

    /* Set to non-NULL to enable CGI, e.g. **.cgi$|**.php$" */
    const(char)* cgi_file_pattern;

    /* If not NULL, ignore CGI script hashbang and use this interpreter */
    const(char)* cgi_interpreter;

    /*
     * Comma-separated list of Content-Type overrides for path suffixes, e.g.
     * ".txt=text/plain; charset=utf-8,.c=text/plain"
     */
    const(char)* custom_mime_types;

    /*
     * Extra HTTP headers to add to each server response.
     * Example: to enable CORS, set this to "Access-Control-Allow-Origin: *".
     */
    const(char)* extra_headers;
}

/*
 * Serves given HTTP request according to the `options`.
 *
 * Example code snippet:
 *
 * ```c
 * static void ev_handler(struct mg_connection *nc, int ev, void *ev_data) {
 *   struct http_message *hm = (struct http_message *) ev_data;
 *   struct mg_serve_http_opts opts = { .document_root = "/var/www" };  // C99
 *
 *   switch (ev) {
 *     case MG_EV_HTTP_REQUEST:
 *       mg_serve_http(nc, hm, opts);
 *       break;
 *     default:
 *       break;
 *   }
 * }
 * ```
 */
void mg_serve_http (
    mg_connection* nc,
    http_message* hm,
    mg_serve_http_opts opts);

/*
 * Serves a specific file with a given MIME type and optional extra headers.
 *
 * Example code snippet:
 *
 * ```c
 * static void ev_handler(struct mg_connection *nc, int ev, void *ev_data) {
 *   switch (ev) {
 *     case MG_EV_HTTP_REQUEST: {
 *       struct http_message *hm = (struct http_message *) ev_data;
 *       mg_http_serve_file(nc, hm, "file.txt",
 *                          mg_mk_str("text/plain"), mg_mk_str(""));
 *       break;
 *     }
 *     ...
 *   }
 * }
 * ```
 */
void mg_http_serve_file (
    mg_connection* nc,
    http_message* hm,
    const(char)* path,
    const mg_str mime_type,
    const mg_str extra_headers);

/* Callback prototype for `mg_file_upload_handler()`. */

/*
 * File upload handler.
 * This handler can be used to implement file uploads with minimum code.
 * This handler will process MG_EV_HTTP_PART_* events and store file data into
 * a local file.
 * `local_name_fn` will be invoked with whatever name was provided by the client
 * and will expect the name of the local file to open. A return value of NULL
 * will abort file upload (client will get a "403 Forbidden" response). If
 * non-null, the returned string must be heap-allocated and will be freed by
 * the caller.
 * Exception: it is ok to return the same string verbatim.
 *
 * Example:
 *
 * ```c
 * struct mg_str upload_fname(struct mg_connection *nc, struct mg_str fname) {
 *   // Just return the same filename. Do not actually do this except in test!
 *   // fname is user-controlled and needs to be sanitized.
 *   return fname;
 * }
 * void ev_handler(struct mg_connection *nc, int ev, void *ev_data) {
 *   switch (ev) {
 *     ...
 *     case MG_EV_HTTP_PART_BEGIN:
 *     case MG_EV_HTTP_PART_DATA:
 *     case MG_EV_HTTP_PART_END:
 *       mg_file_upload_handler(nc, ev, ev_data, upload_fname);
 *       break;
 *   }
 * }
 * ```
 */

/* MG_ENABLE_HTTP_STREAMING_MULTIPART */
/* MG_ENABLE_FILESYSTEM */

/*
 * Registers a callback for a specified http endpoint
 * Note: if callback is registered it is called instead of the
 * callback provided in mg_bind
 *
 * Example code snippet:
 *
 * ```c
 * static void handle_hello1(struct mg_connection *nc, int ev, void *ev_data) {
 *   (void) ev; (void) ev_data;
 *   mg_printf(nc, "HTTP/1.0 200 OK\r\n\r\n[I am Hello1]");
 *  nc->flags |= MG_F_SEND_AND_CLOSE;
 * }
 *
 * static void handle_hello2(struct mg_connection *nc, int ev, void *ev_data) {
 *  (void) ev; (void) ev_data;
 *   mg_printf(nc, "HTTP/1.0 200 OK\r\n\r\n[I am Hello2]");
 *  nc->flags |= MG_F_SEND_AND_CLOSE;
 * }
 *
 * void init() {
 *   nc = mg_bind(&mgr, local_addr, cb1);
 *   mg_register_http_endpoint(nc, "/hello1", handle_hello1);
 *   mg_register_http_endpoint(nc, "/hello1/hello2", handle_hello2);
 * }
 * ```
 */
void mg_register_http_endpoint (
    mg_connection* nc,
    const(char)* uri_path,
    mg_event_handler_t handler);

struct mg_http_endpoint_opts
{
    void* user_data;
    /* Authorization domain (realm) */
    const(char)* auth_domain;
    const(char)* auth_file;
}

void mg_register_http_endpoint_opt (
    mg_connection* nc,
    const(char)* uri_path,
    mg_event_handler_t handler,
    mg_http_endpoint_opts opts);

/*
 * Authenticates a HTTP request against an opened password file.
 * Returns 1 if authenticated, 0 otherwise.
 */
int mg_http_check_digest_auth (
    http_message* hm,
    const(char)* auth_domain,
    FILE* fp);

/*
 * Authenticates given response params against an opened password file.
 * Returns 1 if authenticated, 0 otherwise.
 *
 * It's used by mg_http_check_digest_auth().
 */
int mg_check_digest_auth (
    mg_str method,
    mg_str uri,
    mg_str username,
    mg_str cnonce,
    mg_str response,
    mg_str qop,
    mg_str nc,
    mg_str nonce,
    mg_str auth_domain,
    FILE* fp);

/*
 * Sends buffer `buf` of size `len` to the client using chunked HTTP encoding.
 * This function sends the buffer size as hex number + newline first, then
 * the buffer itself, then the newline. For example,
 * `mg_send_http_chunk(nc, "foo", 3)` will append the `3\r\nfoo\r\n` string
 * to the `nc->send_mbuf` output IO buffer.
 *
 * NOTE: The HTTP header "Transfer-Encoding: chunked" should be sent prior to
 * using this function.
 *
 * NOTE: do not forget to send an empty chunk at the end of the response,
 * to tell the client that everything was sent. Example:
 *
 * ```
 *   mg_printf_http_chunk(nc, "%s", "my response!");
 *   mg_send_http_chunk(nc, "", 0); // Tell the client we're finished
 * ```
 */
void mg_send_http_chunk (mg_connection* nc, const(char)* buf, size_t len);

/*
 * Sends a printf-formatted HTTP chunk.
 * Functionality is similar to `mg_send_http_chunk()`.
 */
void mg_printf_http_chunk (mg_connection* nc, const(char)* fmt, ...);

/*
 * Sends the response status line.
 * If `extra_headers` is not NULL, then `extra_headers` are also sent
 * after the response line. `extra_headers` must NOT end end with new line.
 * Example:
 *
 *      mg_send_response_line(nc, 200, "Access-Control-Allow-Origin: *");
 *
 * Will result in:
 *
 *      HTTP/1.1 200 OK\r\n
 *      Access-Control-Allow-Origin: *\r\n
 */
void mg_send_response_line (
    mg_connection* nc,
    int status_code,
    const(char)* extra_headers);

/*
 * Sends an error response. If reason is NULL, the message will be inferred
 * from the error code (if supported).
 */
void mg_http_send_error (mg_connection* nc, int code, const(char)* reason);

/*
 * Sends a redirect response.
 * `status_code` should be either 301 or 302 and `location` point to the
 * new location.
 * If `extra_headers` is not empty, then `extra_headers` are also sent
 * after the response line. `extra_headers` must NOT end end with new line.
 *
 * Example:
 *
 *      mg_http_send_redirect(nc, 302, mg_mk_str("/login"), mg_mk_str(NULL));
 */
void mg_http_send_redirect (
    mg_connection* nc,
    int status_code,
    const mg_str location,
    const mg_str extra_headers);

/*
 * Sends the response line and headers.
 * This function sends the response line with the `status_code`, and
 * automatically
 * sends one header: either "Content-Length" or "Transfer-Encoding".
 * If `content_length` is negative, then "Transfer-Encoding: chunked" header
 * is sent, otherwise, "Content-Length" header is sent.
 *
 * NOTE: If `Transfer-Encoding` is `chunked`, then message body must be sent
 * using `mg_send_http_chunk()` or `mg_printf_http_chunk()` functions.
 * Otherwise, `mg_send()` or `mg_printf()` must be used.
 * Extra headers could be set through `extra_headers`. Note `extra_headers`
 * must NOT be terminated by a new line.
 */
void mg_send_head (
    mg_connection* n,
    int status_code,
    long content_length,
    const(char)* extra_headers);

/*
 * Sends a printf-formatted HTTP chunk, escaping HTML tags.
 */
void mg_printf_html_escape (mg_connection* nc, const(char)* fmt, ...);

/*
 * Proxies a given request to a given upstream http server. The path prefix
 * in `mount` will be stripped of the path requested to the upstream server,
 * e.g. if mount is /api and upstream is http://localhost:8001/foo
 * then an incoming request to /api/bar will cause a request to
 * http://localhost:8001/foo/bar
 *
 * EXPERIMENTAL API. Please use http_serve_http + url_rewrites if a static
 * mapping is good enough.
 */
void mg_http_reverse_proxy (
    mg_connection* nc,
    const(http_message)* hm,
    mg_str mount,
    mg_str upstream);

/* __cplusplus */

/* MG_ENABLE_HTTP */

/* CS_MONGOOSE_SRC_HTTP_SERVER_H_ */

/*
 * === Client API reference
 */

/* __cplusplus */

/*
 * Helper function that creates an outbound HTTP connection.
 *
 * `url` is the URL to fetch. It must be properly URL-encoded, e.g. have
 * no spaces, etc. By default, `mg_connect_http()` sends the Connection and
 * Host headers. `extra_headers` is an extra HTTP header to send, e.g.
 * `"User-Agent: my-app\r\n"`.
 * If `post_data` is NULL, then a GET request is created. Otherwise, a POST
 * request is created with the specified POST data. Note that if the data being
 * posted is a form submission, the `Content-Type` header should be set
 * accordingly (see example below).
 *
 * Examples:
 *
 * ```c
 *   nc1 = mg_connect_http(mgr, ev_handler_1, "http://www.google.com", NULL,
 *                         NULL);
 *   nc2 = mg_connect_http(mgr, ev_handler_1, "https://github.com", NULL, NULL);
 *   nc3 = mg_connect_http(
 *       mgr, ev_handler_1, "my_server:8000/form_submit/",
 *       "Content-Type: application/x-www-form-urlencoded\r\n",
 *       "var_1=value_1&var_2=value_2");
 * ```
 */
mg_connection* mg_connect_http (
    mg_mgr* mgr,
    mg_event_handler_t event_handler,
    const(char)* url,
    const(char)* extra_headers,
    const(char)* post_data);

/*
 * Helper function that creates an outbound HTTP connection.
 *
 * Mostly identical to mg_connect_http, but allows you to provide extra
 *parameters
 * (for example, SSL parameters)
 */
mg_connection* mg_connect_http_opt (
    mg_mgr* mgr,
    mg_event_handler_t ev_handler,
    mg_connect_opts opts,
    const(char)* url,
    const(char)* extra_headers,
    const(char)* post_data);

/* Creates digest authentication header for a client request. */
int mg_http_create_digest_auth_header (
    char* buf,
    size_t buf_len,
    const(char)* method,
    const(char)* uri,
    const(char)* auth_domain,
    const(char)* user,
    const(char)* passwd,
    const(char)* nonce);

/* __cplusplus */
/* CS_MONGOOSE_SRC_HTTP_CLIENT_H_ */

/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 * This software is dual-licensed: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation. For the terms of this
 * license, see <http://www.gnu.org/licenses/>.
 *
 * You are free to use this software under the terms of the GNU General
 * Public License, but WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * Alternatively, you can license this software under a commercial
 * license, as set out in <https://www.cesanta.com/license>.
 */

/*
 * === MQTT API reference
 */

/* Amalgamated: #include "mg_net.h" */

struct mg_mqtt_message
{
    int cmd;
    int qos;
    int len; /* message length in the IO buffer */
    mg_str topic;
    mg_str payload;

    ubyte connack_ret_code; /* connack */
    ushort message_id; /* puback */

    /* connect */
    ubyte protocol_version;
    ubyte connect_flags;
    ushort keep_alive_timer;
    mg_str protocol_name;
    mg_str client_id;
    mg_str will_topic;
    mg_str will_message;
    mg_str user_name;
    mg_str password;
}

struct mg_mqtt_topic_expression
{
    const(char)* topic;
    ubyte qos;
}

struct mg_send_mqtt_handshake_opts
{
    ubyte flags; /* connection flags */
    ushort keep_alive;
    const(char)* will_topic;
    const(char)* will_message;
    const(char)* user_name;
    const(char)* password;
}

/* mg_mqtt_proto_data should be in header to allow external access to it */
struct mg_mqtt_proto_data
{
    ushort keep_alive;
    double last_control_time;
}

/* Message types */

/* MQTT event types */

/* Message flags */

/* Connection flags */

/* CONNACK return codes */

/* __cplusplus */

/*
 * Attaches a built-in MQTT event handler to the given connection.
 *
 * The user-defined event handler will receive following extra events:
 *
 * - MG_EV_MQTT_CONNACK
 * - MG_EV_MQTT_PUBLISH
 * - MG_EV_MQTT_PUBACK
 * - MG_EV_MQTT_PUBREC
 * - MG_EV_MQTT_PUBREL
 * - MG_EV_MQTT_PUBCOMP
 * - MG_EV_MQTT_SUBACK
 */
void mg_set_protocol_mqtt (mg_connection* nc);

/* Sends an MQTT handshake. */
void mg_send_mqtt_handshake (mg_connection* nc, const(char)* client_id);

/* Sends an MQTT handshake with optional parameters. */
void mg_send_mqtt_handshake_opt (
    mg_connection* nc,
    const(char)* client_id,
    mg_send_mqtt_handshake_opts);

/* Publishes a message to a given topic. */
void mg_mqtt_publish (
    mg_connection* nc,
    const(char)* topic,
    ushort message_id,
    int flags,
    const(void)* data,
    size_t len);

/* Subscribes to a bunch of topics. */
void mg_mqtt_subscribe (
    mg_connection* nc,
    const(mg_mqtt_topic_expression)* topics,
    size_t topics_len,
    ushort message_id);

/* Unsubscribes from a bunch of topics. */
void mg_mqtt_unsubscribe (
    mg_connection* nc,
    char** topics,
    size_t topics_len,
    ushort message_id);

/* Sends a DISCONNECT command. */
void mg_mqtt_disconnect (mg_connection* nc);

/* Sends a CONNACK command with a given `return_code`. */
void mg_mqtt_connack (mg_connection* nc, ubyte return_code);

/* Sends a PUBACK command with a given `message_id`. */
void mg_mqtt_puback (mg_connection* nc, ushort message_id);

/* Sends a PUBREC command with a given `message_id`. */
void mg_mqtt_pubrec (mg_connection* nc, ushort message_id);

/* Sends a PUBREL command with a given `message_id`. */
void mg_mqtt_pubrel (mg_connection* nc, ushort message_id);

/* Sends a PUBCOMP command with a given `message_id`. */
void mg_mqtt_pubcomp (mg_connection* nc, ushort message_id);

/*
 * Sends a SUBACK command with a given `message_id`
 * and a sequence of granted QoSs.
 */
void mg_mqtt_suback (
    mg_connection* nc,
    ubyte* qoss,
    size_t qoss_len,
    ushort message_id);

/* Sends a UNSUBACK command with a given `message_id`. */
void mg_mqtt_unsuback (mg_connection* nc, ushort message_id);

/* Sends a PINGREQ command. */
void mg_mqtt_ping (mg_connection* nc);

/* Sends a PINGRESP command. */
void mg_mqtt_pong (mg_connection* nc);

/*
 * Extracts the next topic expression from a SUBSCRIBE command payload.
 *
 * The topic expression name will point to a string in the payload buffer.
 * Returns the pos of the next topic expression or -1 when the list
 * of topics is exhausted.
 */
int mg_mqtt_next_subscribe_topic (
    mg_mqtt_message* msg,
    mg_str* topic,
    ubyte* qos,
    int pos);

/*
 * Matches a topic against a topic expression
 *
 * Returns 1 if it matches; 0 otherwise.
 */
int mg_mqtt_match_topic_expression (mg_str exp, mg_str topic);

/*
 * Same as `mg_mqtt_match_topic_expression()`, but takes `exp` as a
 * NULL-terminated string.
 */
int mg_mqtt_vmatch_topic_expression (const(char)* exp, mg_str topic);

/* __cplusplus */

/* CS_MONGOOSE_SRC_MQTT_H_ */

/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 * This software is dual-licensed: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation. For the terms of this
 * license, see <http://www.gnu.org/licenses/>.
 *
 * You are free to use this software under the terms of the GNU General
 * Public License, but WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * Alternatively, you can license this software under a commercial
 * license, as set out in <https://www.cesanta.com/license>.
 */

/*
 * === MQTT Server API reference
 */

/* Amalgamated: #include "common/queue.h" */
/* Amalgamated: #include "mg_mqtt.h" */

/* __cplusplus */

/* MQTT session (Broker side). */

/* Broker */
/* mg_mqtt_broker::sessions linkage */
/* Connection with the client */
/* Size of `subscriptions` array */
/* User data */

/* MQTT broker. */

/* Session list */
/* User data */

/* Initialises a MQTT broker. */

/*
 * Processes a MQTT broker message.
 *
 * The listening connection expects a pointer to an initialised
 * `mg_mqtt_broker` structure in the `user_data` field.
 *
 * Basic usage:
 *
 * ```c
 * mg_mqtt_broker_init(&brk, NULL);
 *
 * if ((nc = mg_bind(&mgr, address, mg_mqtt_broker)) == NULL) {
 *   // fail;
 * }
 * nc->user_data = &brk;
 * ```
 *
 * New incoming connections will receive a `mg_mqtt_session` structure
 * in the connection `user_data`. The original `user_data` will be stored
 * in the `user_data` field of the session structure. This allows the user
 * handler to store user data before `mg_mqtt_broker` creates the session.
 *
 * Since only the MG_EV_ACCEPT message is processed by the listening socket,
 * for most events the `user_data` will thus point to a `mg_mqtt_session`.
 */

/*
 * Iterates over all MQTT session connections. Example:
 *
 * ```c
 * struct mg_mqtt_session *s;
 * for (s = mg_mqtt_next(brk, NULL); s != NULL; s = mg_mqtt_next(brk, s)) {
 *   // Do something
 * }
 * ```
 */

/* __cplusplus */

/* MG_ENABLE_MQTT_BROKER */
/* CS_MONGOOSE_SRC_MQTT_BROKER_H_ */

/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */

/*
 * === DNS API reference
 */

/* Amalgamated: #include "mg_net.h" */

/* __cplusplus */

/* Lookup IP address */
/* Lookup CNAME */
/* Lookup PTR */
/* Lookup TXT */
/* Lookup IPv6 address */
/* Lookup SRV */
/* Lookup mail server for domain */

/* High-level DNS message event */

enum mg_dns_resource_record_kind
{
    MG_DNS_INVALID_RECORD = 0,
    MG_DNS_QUESTION = 1,
    MG_DNS_ANSWER = 2
}

/* DNS resource record. */
struct mg_dns_resource_record
{
    mg_str name; /* buffer with compressed name */
    int rtype;
    int rclass;
    int ttl;
    mg_dns_resource_record_kind kind;
    mg_str rdata; /* protocol data (can be a compressed name) */
}

/* DNS message (request and response). */
struct mg_dns_message
{
    mg_str pkt; /* packet body */
    ushort flags;
    ushort transaction_id;
    int num_questions;
    int num_answers;
    mg_dns_resource_record[MG_MAX_DNS_QUESTIONS] questions;
    mg_dns_resource_record[MG_MAX_DNS_ANSWERS] answers;
}

mg_dns_resource_record* mg_dns_next_record (
    mg_dns_message* msg,
    int query,
    mg_dns_resource_record* prev);

/*
 * Parses the record data from a DNS resource record.
 *
 *  - A:     struct in_addr *ina
 *  - AAAA:  struct in6_addr *ina
 *  - CNAME: char buffer
 *
 * Returns -1 on error.
 *
 * TODO(mkm): MX
 */
int mg_dns_parse_record_data (
    mg_dns_message* msg,
    mg_dns_resource_record* rr,
    void* data,
    size_t data_len);

/*
 * Sends a DNS query to the remote end.
 */
void mg_send_dns_query (mg_connection* nc, const(char)* name, int query_type);

/*
 * Inserts a DNS header to an IO buffer.
 *
 * Returns the number of bytes inserted.
 */
int mg_dns_insert_header (mbuf* io, size_t pos, mg_dns_message* msg);

/*
 * Appends already encoded questions from an existing message.
 *
 * This is useful when generating a DNS reply message which includes
 * all question records.
 *
 * Returns the number of appended bytes.
 */
int mg_dns_copy_questions (mbuf* io, mg_dns_message* msg);

/*
 * Encodes and appends a DNS resource record to an IO buffer.
 *
 * The record metadata is taken from the `rr` parameter, while the name and data
 * are taken from the parameters, encoded in the appropriate format depending on
 * record type and stored in the IO buffer. The encoded values might contain
 * offsets within the IO buffer. It's thus important that the IO buffer doesn't
 * get trimmed while a sequence of records are encoded while preparing a DNS
 * reply.
 *
 * This function doesn't update the `name` and `rdata` pointers in the `rr`
 * struct because they might be invalidated as soon as the IO buffer grows
 * again.
 *
 * Returns the number of bytes appended or -1 in case of error.
 */
int mg_dns_encode_record (
    mbuf* io,
    mg_dns_resource_record* rr,
    const(char)* name,
    size_t nlen,
    const(void)* rdata,
    size_t rlen);

/*
 * Encodes a DNS name.
 */
int mg_dns_encode_name (mbuf* io, const(char)* name, size_t len);

/* Low-level: parses a DNS response. */
int mg_parse_dns (const(char)* buf, int len, mg_dns_message* msg);

/*
 * Uncompresses a DNS compressed name.
 *
 * The containing DNS message is required because of the compressed encoding
 * and reference suffixes present elsewhere in the packet.
 *
 * If the name is less than `dst_len` characters long, the remainder
 * of `dst` is terminated with `\0` characters. Otherwise, `dst` is not
 * terminated.
 *
 * If `dst_len` is 0 `dst` can be NULL.
 * Returns the uncompressed name length.
 */
size_t mg_dns_uncompress_name (
    mg_dns_message* msg,
    mg_str* name,
    char* dst,
    int dst_len);

/*
 * Attaches a built-in DNS event handler to the given listening connection.
 *
 * The DNS event handler parses the incoming UDP packets, treating them as DNS
 * requests. If an incoming packet gets successfully parsed by the DNS event
 * handler, a user event handler will receive an `MG_DNS_REQUEST` event, with
 * `ev_data` pointing to the parsed `struct mg_dns_message`.
 *
 * See
 * [captive_dns_server](https://github.com/cesanta/mongoose/tree/master/examples/captive_dns_server)
 * example on how to handle DNS request and send DNS reply.
 */
void mg_set_protocol_dns (mg_connection* nc);

/* __cplusplus */
/* CS_MONGOOSE_SRC_DNS_H_ */

/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */

/*
 * === DNS server API reference
 *
 * Disabled by default; enable with `-DMG_ENABLE_DNS_SERVER`.
 */

/* Amalgamated: #include "mg_dns.h" */

/* __cplusplus */

/*
 * Creates a DNS reply.
 *
 * The reply will be based on an existing query message `msg`.
 * The query body will be appended to the output buffer.
 * "reply + recursion allowed" will be added to the message flags and the
 * message's num_answers will be set to 0.
 *
 * Answer records can be appended with `mg_dns_send_reply` or by lower
 * level function defined in the DNS API.
 *
 * In order to send a reply use `mg_dns_send_reply`.
 * It's possible to use a connection's send buffer as reply buffer,
 * and it will work for both UDP and TCP connections.
 *
 * Example:
 *
 * ```c
 * reply = mg_dns_create_reply(&nc->send_mbuf, msg);
 * for (i = 0; i < msg->num_questions; i++) {
 *   rr = &msg->questions[i];
 *   if (rr->rtype == MG_DNS_A_RECORD) {
 *     mg_dns_reply_record(&reply, rr, 3600, &dummy_ip_addr, 4);
 *   }
 * }
 * mg_dns_send_reply(nc, &reply);
 * ```
 */

/*
 * Appends a DNS reply record to the IO buffer and to the DNS message.
 *
 * The message's num_answers field will be incremented. It's the caller's duty
 * to ensure num_answers is properly initialised.
 *
 * Returns -1 on error.
 */

/*
 * Sends a DNS reply through a connection.
 *
 * The DNS data is stored in an IO buffer pointed by reply structure in `r`.
 * This function mutates the content of that buffer in order to ensure that
 * the DNS header reflects the size and flags of the message, that might have
 * been updated either with `mg_dns_reply_record` or by direct manipulation of
 * `r->message`.
 *
 * Once sent, the IO buffer will be trimmed unless the reply IO buffer
 * is the connection's send buffer and the connection is not in UDP mode.
 */

/* __cplusplus */

/* MG_ENABLE_DNS_SERVER */
/* CS_MONGOOSE_SRC_DNS_SERVER_H_ */

/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */

/*
 * === API reference
 */

/* Amalgamated: #include "mg_dns.h" */

/* __cplusplus */

enum mg_resolve_err
{
    MG_RESOLVE_OK = 0,
    MG_RESOLVE_NO_ANSWERS = 1,
    MG_RESOLVE_EXCEEDED_RETRY_COUNT = 2,
    MG_RESOLVE_TIMEOUT = 3
}

alias mg_resolve_callback_t = void function (
    mg_dns_message* dns_message,
    void* user_data,
    mg_resolve_err);

/* Options for `mg_resolve_async_opt`. */
struct mg_resolve_async_opts
{
    const(char)* nameserver;
    int max_retries; /* defaults to 2 if zero */
    int timeout; /* in seconds; defaults to 5 if zero */
    int accept_literal; /* pseudo-resolve literal ipv4 and ipv6 addrs */
    int only_literal; /* only resolves literal addrs; sync cb invocation */
    mg_connection** dns_conn; /* return DNS connection */
}

/* See `mg_resolve_async_opt()` */
int mg_resolve_async (
    mg_mgr* mgr,
    const(char)* name,
    int query,
    mg_resolve_callback_t cb,
    void* data);

/* Set default DNS server */
void mg_set_nameserver (mg_mgr* mgr, const(char)* nameserver);

/*
 * Resolved a DNS name asynchronously.
 *
 * Upon successful resolution, the user callback will be invoked
 * with the full DNS response message and a pointer to the user's
 * context `data`.
 *
 * In case of timeout while performing the resolution the callback
 * will receive a NULL `msg`.
 *
 * The DNS answers can be extracted with `mg_next_record` and
 * `mg_dns_parse_record_data`:
 *
 * [source,c]
 * ----
 * struct in_addr ina;
 * struct mg_dns_resource_record *rr = mg_next_record(msg, MG_DNS_A_RECORD,
 *   NULL);
 * mg_dns_parse_record_data(msg, rr, &ina, sizeof(ina));
 * ----
 */
int mg_resolve_async_opt (
    mg_mgr* mgr,
    const(char)* name,
    int query,
    mg_resolve_callback_t cb,
    void* data,
    mg_resolve_async_opts opts);

/*
 * Resolve a name from `/etc/hosts`.
 *
 * Returns 0 on success, -1 on failure.
 */
int mg_resolve_from_hosts_file (const(char)* host, socket_address* usa);
enum MBUF_SIZE_MULTIPLIER = 1.5;
enum MBUF_SIZE_MAX_HEADROOM = BUFSIZ;
enum DISABLE_BASE64 = 0;
enum CS_ENABLE_STRDUP = 0;
enum CS_ENABLE_TO64 = 0;

extern (D) auto SLIST_EMPTY(T)(auto ref T head)
{
    return head.slh_first == NULL;
}

extern (D) auto SLIST_FIRST(T)(auto ref T head)
{
    return head.slh_first;
}

extern (D) auto SLIST_NEXT(T0, T1)(auto ref T0 elm, auto ref T1 field)
{
    return elm.field.sle_next;
}

extern (D) auto STAILQ_EMPTY(T)(auto ref T head)
{
    return head.stqh_first == NULL;
}

extern (D) auto STAILQ_FIRST(T)(auto ref T head)
{
    return head.stqh_first;
}

extern (D) auto STAILQ_LAST(T0, T1, T2)(auto ref T0 head, auto ref T1 type, auto ref T2 field)
{
    return STAILQ_EMPTY(head) ? NULL : __containerof(head.stqh_last, QUEUE_TYPEOF(type), field.stqe_next);
}

extern (D) auto STAILQ_NEXT(T0, T1)(auto ref T0 elm, auto ref T1 field)
{
    return elm.field.stqe_next;
}

extern (D) auto LIST_EMPTY(T)(auto ref T head)
{
    return head.lh_first == NULL;
}

extern (D) auto LIST_FIRST(T)(auto ref T head)
{
    return head.lh_first;
}

extern (D) auto LIST_NEXT(T0, T1)(auto ref T0 elm, auto ref T1 field)
{
    return elm.field.le_next;
}

extern (D) auto LIST_PREV(T0, T1, T2, T3)(auto ref T0 elm, auto ref T1 head, auto ref T2 type, auto ref T3 field)
{
    return elm.field.le_prev == &LIST_FIRST(head) ? NULL : __containerof(elm.field.le_prev, QUEUE_TYPEOF(type), field.le_next);
}

extern (D) auto TAILQ_EMPTY(T)(auto ref T head)
{
    return head.tqh_first == NULL;
}

extern (D) auto TAILQ_FIRST(T)(auto ref T head)
{
    return head.tqh_first;
}

extern (D) auto TAILQ_NEXT(T0, T1)(auto ref T0 elm, auto ref T1 field)
{
    return elm.field.tqe_next;
}

enum MG_DISABLE_HTTP_DIGEST_AUTH = 0;
enum MG_DISABLE_HTTP_KEEP_ALIVE = 0;
enum MG_DISABLE_PFS = 0;
enum MG_DISABLE_WS_RANDOM_MASK = 0;
enum MG_ENABLE_ASYNC_RESOLVER = 1;
enum MG_ENABLE_COAP = 0;
enum MG_ENABLE_DEBUG = 0;
enum MG_ENABLE_DNS = 1;
enum MG_ENABLE_DNS_SERVER = 0;
enum MG_ENABLE_FAKE_DAVLOCK = 0;
enum MG_ENABLE_GETADDRINFO = 0;
enum MG_ENABLE_HEXDUMP = CS_ENABLE_STDIO;
enum MG_ENABLE_HTTP = 1;
enum MG_ENABLE_HTTP_SSI = MG_ENABLE_FILESYSTEM;
enum MG_ENABLE_HTTP_SSI_EXEC = 0;
enum MG_ENABLE_HTTP_STREAMING_MULTIPART = 0;
enum MG_ENABLE_HTTP_WEBDAV = 0;
enum MG_ENABLE_HTTP_WEBSOCKET = MG_ENABLE_HTTP;
enum MG_ENABLE_IPV6 = 0;
enum MG_ENABLE_MQTT = 1;
enum MG_ENABLE_SOCKS = 0;
enum MG_ENABLE_MQTT_BROKER = 0;
enum MG_ENABLE_SSL = 0;
enum MG_ENABLE_SYNC_RESOLVER = 0;
enum MG_ENABLE_STDIO = CS_ENABLE_STDIO;
enum MG_SSL_IF = MG_SSL_IF_OPENSSL;
enum MG_ENABLE_THREADS = 0;
enum MG_ENABLE_HTTP_URL_REWRITES = CS_PLATFORM == CS_P_WINDOWS || CS_PLATFORM == CS_P_UNIX;
enum MG_ENABLE_SNTP = 0;
enum MG_ENABLE_EXTRA_ERRORS_DESC = 0;
enum MG_ENABLE_CALLBACK_USERDATA = 0;

extern (D) auto MG_CB(T0, T1)(auto ref T0 cb, auto ref T1 ud)
{
    return cb;
}

enum MG_MAIN_IFACE = 0;
enum MG_VPRINTF_BUFFER_SIZE = 100;
alias MG_RECV_FUNC = recv;
alias MG_SEND_FUNC = send;
enum MG_EV_POLL = 0;
enum MG_EV_ACCEPT = 1;
enum MG_EV_CONNECT = 2;
enum MG_EV_RECV = 3;
enum MG_EV_SEND = 4;
enum MG_EV_CLOSE = 5;
enum MG_EV_TIMER = 6;
enum MG_F_LISTENING = 1 << 0;
enum MG_F_UDP = 1 << 1;
enum MG_F_RESOLVING = 1 << 2;
enum MG_F_CONNECTING = 1 << 3;
enum MG_F_SSL = 1 << 4;
enum MG_F_SSL_HANDSHAKE_DONE = 1 << 5;
enum MG_F_WANT_READ = 1 << 6;
enum MG_F_WANT_WRITE = 1 << 7;
enum MG_F_IS_WEBSOCKET = 1 << 8;
enum MG_F_RECV_AND_CLOSE = 1 << 9;
enum MG_F_SEND_AND_CLOSE = 1 << 10;
enum MG_F_CLOSE_IMMEDIATELY = 1 << 11;
enum MG_F_WEBSOCKET_NO_DEFRAG = 1 << 12;
enum MG_F_DELETE_CHUNK = 1 << 13;
enum MG_F_ENABLE_BROADCAST = 1 << 14;
enum MG_F_USER_1 = 1 << 20;
enum MG_F_USER_2 = 1 << 21;
enum MG_F_USER_3 = 1 << 22;
enum MG_F_USER_4 = 1 << 23;
enum MG_F_USER_5 = 1 << 24;
enum MG_F_USER_6 = 1 << 25;
enum PATH_MAX = 108;
enum MG_MAX_PATH = PATH_MAX;
enum MG_SOCK_STRINGIFY_IP = 1;
enum MG_SOCK_STRINGIFY_PORT = 2;
enum MG_SOCK_STRINGIFY_REMOTE = 4;
enum MG_URL_ENCODE_F_SPACE_AS_PLUS = 1 << 0;
enum MG_URL_ENCODE_F_UPPERCASE_HEX = 1 << 1;
enum MG_CGI_ENVIRONMENT_SIZE = 8192;
enum MG_EV_HTTP_REQUEST = 100;
enum MG_EV_HTTP_REPLY = 101;
enum MG_EV_HTTP_CHUNK = 102;
enum MG_EV_SSI_CALL = 105;
enum MG_EV_SSI_CALL_CTX = 106;
enum MG_EV_WEBSOCKET_HANDSHAKE_REQUEST = 111;
enum MG_EV_WEBSOCKET_HANDSHAKE_DONE = 112;
enum MG_EV_WEBSOCKET_FRAME = 113;
enum MG_EV_WEBSOCKET_CONTROL_FRAME = 114;
enum WEBSOCKET_OP_CONTINUE = 0;
enum WEBSOCKET_OP_TEXT = 1;
enum WEBSOCKET_OP_BINARY = 2;
enum WEBSOCKET_OP_CLOSE = 8;
enum WEBSOCKET_OP_PING = 9;
enum WEBSOCKET_OP_PONG = 10;
enum WEBSOCKET_DONT_FIN = 0x100;
enum MG_AUTH_FLAG_IS_DIRECTORY = 1 << 0;
enum MG_AUTH_FLAG_IS_GLOBAL_PASS_FILE = 1 << 1;
enum MG_AUTH_FLAG_ALLOW_MISSING_FILE = 1 << 2;
enum MG_MQTT_CMD_CONNECT = 1;
enum MG_MQTT_CMD_CONNACK = 2;
enum MG_MQTT_CMD_PUBLISH = 3;
enum MG_MQTT_CMD_PUBACK = 4;
enum MG_MQTT_CMD_PUBREC = 5;
enum MG_MQTT_CMD_PUBREL = 6;
enum MG_MQTT_CMD_PUBCOMP = 7;
enum MG_MQTT_CMD_SUBSCRIBE = 8;
enum MG_MQTT_CMD_SUBACK = 9;
enum MG_MQTT_CMD_UNSUBSCRIBE = 10;
enum MG_MQTT_CMD_UNSUBACK = 11;
enum MG_MQTT_CMD_PINGREQ = 12;
enum MG_MQTT_CMD_PINGRESP = 13;
enum MG_MQTT_CMD_DISCONNECT = 14;
enum MG_MQTT_EVENT_BASE = 200;
enum MG_EV_MQTT_CONNECT = MG_MQTT_EVENT_BASE + MG_MQTT_CMD_CONNECT;
enum MG_EV_MQTT_CONNACK = MG_MQTT_EVENT_BASE + MG_MQTT_CMD_CONNACK;
enum MG_EV_MQTT_PUBLISH = MG_MQTT_EVENT_BASE + MG_MQTT_CMD_PUBLISH;
enum MG_EV_MQTT_PUBACK = MG_MQTT_EVENT_BASE + MG_MQTT_CMD_PUBACK;
enum MG_EV_MQTT_PUBREC = MG_MQTT_EVENT_BASE + MG_MQTT_CMD_PUBREC;
enum MG_EV_MQTT_PUBREL = MG_MQTT_EVENT_BASE + MG_MQTT_CMD_PUBREL;
enum MG_EV_MQTT_PUBCOMP = MG_MQTT_EVENT_BASE + MG_MQTT_CMD_PUBCOMP;
enum MG_EV_MQTT_SUBSCRIBE = MG_MQTT_EVENT_BASE + MG_MQTT_CMD_SUBSCRIBE;
enum MG_EV_MQTT_SUBACK = MG_MQTT_EVENT_BASE + MG_MQTT_CMD_SUBACK;
enum MG_EV_MQTT_UNSUBSCRIBE = MG_MQTT_EVENT_BASE + MG_MQTT_CMD_UNSUBSCRIBE;
enum MG_EV_MQTT_UNSUBACK = MG_MQTT_EVENT_BASE + MG_MQTT_CMD_UNSUBACK;
enum MG_EV_MQTT_PINGREQ = MG_MQTT_EVENT_BASE + MG_MQTT_CMD_PINGREQ;
enum MG_EV_MQTT_PINGRESP = MG_MQTT_EVENT_BASE + MG_MQTT_CMD_PINGRESP;
enum MG_EV_MQTT_DISCONNECT = MG_MQTT_EVENT_BASE + MG_MQTT_CMD_DISCONNECT;
enum MG_MQTT_RETAIN = 0x1;
enum MG_MQTT_DUP = 0x4;

extern (D) auto MG_MQTT_QOS(T)(auto ref T qos)
{
    return qos << 1;
}

extern (D) auto MG_MQTT_GET_QOS(T)(auto ref T flags)
{
    return (flags & 0x6) >> 1;
}

enum MG_MQTT_CLEAN_SESSION = 0x02;
enum MG_MQTT_HAS_WILL = 0x04;
enum MG_MQTT_WILL_RETAIN = 0x20;
enum MG_MQTT_HAS_PASSWORD = 0x40;
enum MG_MQTT_HAS_USER_NAME = 0x80;

extern (D) auto MG_MQTT_GET_WILL_QOS(T)(auto ref T flags)
{
    return (flags & 0x18) >> 3;
}

enum MG_EV_MQTT_CONNACK_ACCEPTED = 0;
enum MG_EV_MQTT_CONNACK_UNACCEPTABLE_VERSION = 1;
enum MG_EV_MQTT_CONNACK_IDENTIFIER_REJECTED = 2;
enum MG_EV_MQTT_CONNACK_SERVER_UNAVAILABLE = 3;
enum MG_EV_MQTT_CONNACK_BAD_AUTH = 4;
enum MG_EV_MQTT_CONNACK_NOT_AUTHORIZED = 5;
enum MG_DNS_A_RECORD = 0x01;
enum MG_DNS_CNAME_RECORD = 0x05;
enum MG_DNS_PTR_RECORD = 0x0c;
enum MG_DNS_TXT_RECORD = 0x10;
enum MG_DNS_AAAA_RECORD = 0x1c;
enum MG_DNS_SRV_RECORD = 0x21;
enum MG_DNS_MX_RECORD = 0x0f;
enum MG_DNS_ANY_RECORD = 0xff;
enum MG_DNS_NSEC_RECORD = 0x2f;
enum MG_MAX_DNS_QUESTIONS = 32;
enum MG_MAX_DNS_ANSWERS = 32;
enum MG_DNS_MESSAGE = 100;

/* __cplusplus */
/* CS_MONGOOSE_SRC_RESOLV_H_ */

/*
 * Copyright (c) 2015 Cesanta Software Limited
 * All rights reserved
 * This software is dual-licensed: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation. For the terms of this
 * license, see <http://www.gnu.org/licenses/>.
 *
 * You are free to use this software under the terms of the GNU General
 * Public License, but WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * Alternatively, you can license this software under a commercial
 * license, as set out in <https://www.cesanta.com/license>.
 */

/*
 * === CoAP API reference
 *
 * CoAP message format:
 *
 * ```
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
 * |Ver| T | TKL | Code | Message ID | Token (if any, TKL bytes) ...
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
 * | Options (if any) ...            |1 1 1 1 1 1 1 1| Payload (if any) ...
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
 * ```
 */

/*
 * CoAP options.
 * Use mg_coap_add_option and mg_coap_free_options
 * for creation and destruction.
 */

/* CoAP message. See RFC 7252 for details. */

/* __cplusplus */

/* Sets CoAP protocol handler - triggers CoAP specific events. */

/*
 * Adds a new option to mg_coap_message structure.
 * Returns pointer to the newly created option.
 * Note: options must be freed by using mg_coap_free_options
 */

/*
 * Frees the memory allocated for options.
 * If the cm parameter doesn't contain any option it does nothing.
 */

/*
 * Composes a CoAP message from `mg_coap_message`
 * and sends it into `nc` connection.
 * Returns 0 on success. On error, it is a bitmask:
 *
 * - `#define MG_COAP_ERROR 0x10000`
 * - `#define MG_COAP_FORMAT_ERROR (MG_COAP_ERROR | 0x20000)`
 * - `#define MG_COAP_IGNORE (MG_COAP_ERROR | 0x40000)`
 * - `#define MG_COAP_NOT_ENOUGH_DATA (MG_COAP_ERROR | 0x80000)`
 * - `#define MG_COAP_NETWORK_ERROR (MG_COAP_ERROR | 0x100000)`
 */

/*
 * Composes CoAP acknowledgement from `mg_coap_message`
 * and sends it into `nc` connection.
 * Return value: see `mg_coap_send_message()`
 */

/*
 * Parses CoAP message and fills mg_coap_message and returns cm->flags.
 * This is a helper function.
 *
 * NOTE: usually CoAP works over UDP, so lack of data means format error.
 * But, in theory, it is possible to use CoAP over TCP (according to RFC)
 *
 * The caller has to check results and treat COAP_NOT_ENOUGH_DATA according to
 * underlying protocol:
 *
 * - in case of UDP COAP_NOT_ENOUGH_DATA means COAP_FORMAT_ERROR,
 * - in case of TCP client can try to receive more data
 *
 * Return value: see `mg_coap_send_message()`
 */

/*
 * Composes CoAP message from mg_coap_message structure.
 * This is a helper function.
 * Return value: see `mg_coap_send_message()`
 */

/* __cplusplus */

/* MG_ENABLE_COAP */

/* CS_MONGOOSE_SRC_COAP_H_ */

/*
 * Copyright (c) 2016 Cesanta Software Limited
 * All rights reserved
 */

/*
 * Received reply from time server. Event handler parameter contains
 * pointer to mg_sntp_message structure
 */

/* Received malformed SNTP packet */

/* Failed to get time from server (timeout etc) */

/* if server sends this flags, user should not send requests to it */

/* usual mg_time */

/* Establishes connection to given sntp server */

/* Sends time request to given connection */

/*
 * Helper function
 * Establishes connection to time server, tries to send request
 * repeats sending SNTP_ATTEMPTS times every SNTP_TIMEOUT sec
 * (if needed)
 * See sntp_client example
 */

/* CS_MONGOOSE_SRC_SNTP_H_ */

/*
 * Copyright (c) 2017 Cesanta Software Limited
 * All rights reserved
 */

/* SOCKS5 handshake methods */

/* Handshake method - no authentication */
/* Handshake method - GSSAPI auth */
/* Handshake method - user/password auth */
/* Handshake method - failure */

/* SOCKS5 commands */

/* Command: CONNECT */
/* Command: BIND */
/* Command: UDP ASSOCIATE */

/* SOCKS5 address types */

/* Address type: IPv4 */
/* Address type: Domain name */
/* Address type: IPv6 */

/* SOCKS5 response codes */

/* Response: success */
/* Response: failure */
/* Response: connection not allowed */
/* Response: network unreachable */
/* Response: network unreachable */
/* Response: network unreachable */
/* Response: network unreachable */
/* Response: network unreachable */
/* Response: network unreachable */

/* __cplusplus */

/* Turn the connection into the SOCKS server */

/* Create socks tunnel for the client connection */

/* __cplusplus */

